use dashu_float::{DBig, Context};
use dashu_float::round::mode::HalfAway;
use dashu_base::Approximation::{Exact, Inexact};
use dashu_base::Approximation;
use dashu_base::Abs;
use std::str::FromStr;
use libm;

mod dashu_float_precision_tests {
    use super::*;

    // Test configuration
    const HIGH_PRECISION_DIGITS: usize = 200;

    /// Helper function to create high-precision context
    fn high_precision_ctx() -> Context<HalfAway> {
        Context::<HalfAway>::new(HIGH_PRECISION_DIGITS)
    }

    /// Helper function to convert f64 to high-precision DBig
    fn f64_to_dbig(val: f64) -> DBig {
        let val_str = format!("{}", val);
        DBig::from_str(&val_str)
            .unwrap()
            .with_precision(HIGH_PRECISION_DIGITS)
            .unwrap()
    }

    /// Helper function to extract f64 from Approximation
    fn extract_f64(approx: Approximation<f64, dashu_float::round::Rounding>) -> f64 {
        match approx {
            Exact(val) => val,
            Inexact(val, _) => val,
        }
    }

    /// Helper function to convert TwoFloat to DBig using hi and lo components with maximum precision
    fn twofloat_to_dbig_high_precision(val: twofloat::TwoFloat) -> DBig {
        // Access TwoFloat's internal hi and lo components
        let hi = val.hi();
        let lo = val.lo();
        
        // Use higher precision string formatting to preserve more digits
        let hi_str = format!("{:.34e}", hi);
        let lo_str = format!("{:.34e}", lo);
        
        // Parse with higher precision context
        let ctx_high = Context::<HalfAway>::new(200); // Use 200 digits for intermediate calculations
        
        let hi_dbig = DBig::from_str(&hi_str)
            .unwrap()
            .with_precision(200)
            .unwrap();
        let lo_dbig = DBig::from_str(&lo_str)
            .unwrap()
            .with_precision(200)
            .unwrap();
        
        // Add hi + lo with high precision
        let sum = hi_dbig + lo_dbig;
        
        // Return with the target precision
        sum.with_precision(HIGH_PRECISION_DIGITS).unwrap()
    }

    /// Ultra-high precision TwoFloat to DBig conversion using bit manipulation
    fn twofloat_to_dbig_ultra_precision(val: twofloat::TwoFloat) -> DBig {
        use sparseir_rust::CustomNumeric;
        
        // Access TwoFloat's internal hi and lo components
        let hi = val.hi();
        let lo = val.lo();
        
        // Convert to f64 first, then use the most precise string representation
        let val_f64 = val.to_f64();
        
        // Use a very high precision string format
        // This preserves the maximum precision from TwoFloat's internal representation
        let val_str = format!("{:.17e}", val_f64);
        
        // Parse with ultra-high precision
        let dbig = DBig::from_str(&val_str)
            .unwrap()
            .with_precision(200)
            .unwrap();
        
        // Return with target precision
        dbig.with_precision(HIGH_PRECISION_DIGITS).unwrap()
    }

    /// Helper function to convert TwoFloat to DBig (legacy method using to_f64)
    fn twofloat_to_dbig(val: twofloat::TwoFloat) -> DBig {
        use sparseir_rust::CustomNumeric;
        let val_f64 = val.to_f64();
        let val_str = format!("{:.17e}", val_f64);  // Use scientific notation to preserve precision
        DBig::from_str(&val_str)
            .unwrap()
            .with_precision(HIGH_PRECISION_DIGITS)
            .unwrap()
    }

    #[test]
    fn test_dbig_exp_minus_one_convergence() {
        println!("DBig exp(-1) convergence test:");
        println!("===============================");
        
        // Julia BigFloat reference (200 digits)
        let julia_reference_str = "0.36787944117144232159552377016146086744581113103176783450783671";
        let julia_reference = DBig::from_str(julia_reference_str).unwrap().with_precision(200).unwrap();
        
        println!("Julia BigFloat reference (200 digits):");
        println!("{}", julia_reference_str);
        println!();
        
        let val = -1.0;
        let dbig_val = f64_to_dbig(val);
        
        // Test with different precision settings using different Context instances
        for precision in [20, 30, 40, 50, 60, 70, 80, 90, 100] {
            // Create context with specific precision
            let ctx = Context::<HalfAway>::new(precision);
            
            let dbig_high_precision = dbig_val.clone().with_precision(precision).unwrap();
            let dbig_result = match ctx.exp(dbig_high_precision.repr()) {
                Exact(result) => result,
                Inexact(result, _) => result,
            };
            
            // Calculate difference with Julia reference
            let diff = (&dbig_result - &julia_reference).abs();
            let rel_error = if julia_reference == DBig::ZERO {
                extract_f64(diff.to_f64())
            } else {
                let diff_f64 = extract_f64(diff.to_f64());
                let julia_f64 = extract_f64(julia_reference.to_f64());
                diff_f64 / julia_f64.abs()
            };
            
            println!("{} digits: {}", precision, dbig_result.to_string());
            println!("         diff={:.2e}, rel_error={:.2e}", 
                     extract_f64(diff.to_f64()), rel_error);
            println!();
        }
    }

    #[test]
    fn test_twofloat_vs_dbig_exp_minus_one() {
        use twofloat::TwoFloat;
        use sparseir_rust::CustomNumeric;
        
        println!("TwoFloat vs DBig exp(-1) precision test:");
        println!("========================================");
        
        // DBig reference (100 digits precision)
        let ctx_100 = Context::<HalfAway>::new(100);
        let val = -1.0;
        let dbig_val = f64_to_dbig(val);
        let dbig_100 = dbig_val.with_precision(100).unwrap();
        let dbig_result = match ctx_100.exp(dbig_100.repr()) {
            Exact(result) => result,
            Inexact(result, _) => result,
        };
        
        println!("DBig reference (100 digits):");
        println!("{}", dbig_result.to_string());
        println!();
        
        // TwoFloat calculation
        let twofloat_val = TwoFloat::from_f64(val);
        let twofloat_result = twofloat_val.exp();
        
        println!("TwoFloat result:");
        println!("{}", twofloat_result.to_f64());
        println!();
        
        // Convert TwoFloat to DBig for comparison
        let twofloat_as_dbig = twofloat_to_dbig(twofloat_result);
        let twofloat_as_dbig_100 = twofloat_as_dbig.with_precision(100).unwrap();
        
        // Calculate difference
        let diff = (&dbig_result - &twofloat_as_dbig_100).abs();
        let rel_error = if dbig_result == DBig::ZERO {
            extract_f64(diff.to_f64())
        } else {
            let diff_f64 = extract_f64(diff.to_f64());
            let dbig_f64 = extract_f64(dbig_result.to_f64());
            diff_f64 / dbig_f64.abs()
        };
        
        println!("Precision comparison:");
        println!("  DBig (100 digits):    {}", dbig_result.to_string());
        println!("  TwoFloat:             {}", twofloat_result.to_f64());
        println!("  TwoFloat as DBig:     {}", twofloat_as_dbig_100.to_string());
        println!("  Absolute difference:  {:.2e}", extract_f64(diff.to_f64()));
        println!("  Relative error:       {:.2e}", rel_error);
        
        // Determine effective precision of TwoFloat
        let effective_precision = -rel_error.log10();
        println!("  TwoFloat effective precision: ~{:.1} digits", effective_precision);
    }

    #[test]
    fn test_twofloat_vs_dbig_exp_minus_one_high_precision() {
        use twofloat::TwoFloat;
        use sparseir_rust::CustomNumeric;
        
        println!("TwoFloat vs DBig exp(-1) HIGH PRECISION test:");
        println!("==============================================");
        
        // DBig reference (100 digits precision)
        let ctx_100 = Context::<HalfAway>::new(100);
        let val = -1.0;
        let dbig_val = f64_to_dbig(val);
        let dbig_100 = dbig_val.with_precision(100).unwrap();
        let dbig_result = match ctx_100.exp(dbig_100.repr()) {
            Exact(result) => result,
            Inexact(result, _) => result,
        };
        
        println!("DBig reference (100 digits):");
        println!("{}", dbig_result.to_string());
        println!();
        
        // TwoFloat calculation
        let twofloat_val = TwoFloat::from_f64(val);
        let twofloat_result = twofloat_val.exp();
        
        println!("TwoFloat result:");
        println!("  TwoFloat: {}", twofloat_result.to_f64());
        println!("  TwoFloat hi: {}", twofloat_result.hi());
        println!("  TwoFloat lo: {}", twofloat_result.lo());
        println!();
        
        // Convert TwoFloat to DBig using high precision method (hi + lo)
        let twofloat_as_dbig_high_prec = twofloat_to_dbig_high_precision(twofloat_result);
        let twofloat_as_dbig_100_high_prec = twofloat_as_dbig_high_prec.with_precision(100).unwrap();
        
        // Also convert using legacy method (to_f64) for comparison
        let twofloat_as_dbig_legacy = twofloat_to_dbig(twofloat_result);
        let twofloat_as_dbig_100_legacy = twofloat_as_dbig_legacy.with_precision(100).unwrap();
        
        // Calculate differences
        let diff_high_prec = (&dbig_result - &twofloat_as_dbig_100_high_prec).abs();
        let diff_legacy = (&dbig_result - &twofloat_as_dbig_100_legacy).abs();
        
        let rel_error_high_prec = if dbig_result == DBig::ZERO {
            extract_f64(diff_high_prec.to_f64())
        } else {
            let diff_f64 = extract_f64(diff_high_prec.to_f64());
            let dbig_f64 = extract_f64(dbig_result.to_f64());
            diff_f64 / dbig_f64.abs()
        };
        
        let rel_error_legacy = if dbig_result == DBig::ZERO {
            extract_f64(diff_legacy.to_f64())
        } else {
            let diff_f64 = extract_f64(diff_legacy.to_f64());
            let dbig_f64 = extract_f64(dbig_result.to_f64());
            diff_f64 / dbig_f64.abs()
        };
        
        println!("Precision comparison:");
        println!("  DBig (100 digits):                {}", dbig_result.to_string());
        println!("  TwoFloat (hi+lo method):          {}", twofloat_as_dbig_100_high_prec.to_string());
        println!("  TwoFloat (legacy to_f64 method):  {}", twofloat_as_dbig_100_legacy.to_string());
        println!();
        println!("  High precision method:");
        println!("    Absolute difference:  {:.2e}", extract_f64(diff_high_prec.to_f64()));
        println!("    Relative error:       {:.2e}", rel_error_high_prec);
        println!("    Effective precision:  ~{:.1} digits", -rel_error_high_prec.log10());
        println!();
        println!("  Legacy to_f64 method:");
        println!("    Absolute difference:  {:.2e}", extract_f64(diff_legacy.to_f64()));
        println!("    Relative error:       {:.2e}", rel_error_legacy);
        println!("    Effective precision:  ~{:.1} digits", -rel_error_legacy.log10());
        println!();
        println!("  Precision improvement:  {:.1}x better", rel_error_legacy / rel_error_high_prec);
    }

    #[test]
    fn test_twofloat_vs_dbig_exp_plus_one() {
        use twofloat::TwoFloat;
        use sparseir_rust::CustomNumeric;
        
        println!("TwoFloat vs DBig exp(1) precision test:");
        println!("=======================================");
        
        // DBig reference (100 digits precision)
        let ctx_100 = Context::<HalfAway>::new(100);
        let val = 1.0;
        let dbig_val = f64_to_dbig(val);
        let dbig_100 = dbig_val.with_precision(100).unwrap();
        let dbig_result = match ctx_100.exp(dbig_100.repr()) {
            Exact(result) => result,
            Inexact(result, _) => result,
        };
        
        println!("DBig reference (100 digits):");
        println!("{}", dbig_result.to_string());
        println!();
        
        // TwoFloat calculation
        let twofloat_val = TwoFloat::from_f64(val);
        let twofloat_result = twofloat_val.exp();
        
        println!("TwoFloat result:");
        println!("  TwoFloat: {}", twofloat_result.to_f64());
        println!("  TwoFloat hi: {}", twofloat_result.hi());
        println!("  TwoFloat lo: {}", twofloat_result.lo());
        println!();
        
        // Convert TwoFloat to DBig using high precision method (hi + lo)
        let twofloat_as_dbig_high_prec = twofloat_to_dbig_high_precision(twofloat_result);
        let twofloat_as_dbig_100_high_prec = twofloat_as_dbig_high_prec.with_precision(100).unwrap();
        
        // Also convert using legacy method (to_f64) for comparison
        let twofloat_as_dbig_legacy = twofloat_to_dbig(twofloat_result);
        let twofloat_as_dbig_100_legacy = twofloat_as_dbig_legacy.with_precision(100).unwrap();
        
        // Calculate differences
        let diff_high_prec = (&dbig_result - &twofloat_as_dbig_100_high_prec).abs();
        let diff_legacy = (&dbig_result - &twofloat_as_dbig_100_legacy).abs();
        
        let rel_error_high_prec = if dbig_result == DBig::ZERO {
            extract_f64(diff_high_prec.to_f64())
        } else {
            let diff_f64 = extract_f64(diff_high_prec.to_f64());
            let dbig_f64 = extract_f64(dbig_result.to_f64());
            diff_f64 / dbig_f64.abs()
        };
        
        let rel_error_legacy = if dbig_result == DBig::ZERO {
            extract_f64(diff_legacy.to_f64())
        } else {
            let diff_f64 = extract_f64(diff_legacy.to_f64());
            let dbig_f64 = extract_f64(dbig_result.to_f64());
            diff_f64 / dbig_f64.abs()
        };
        
        println!("Precision comparison:");
        println!("  DBig (100 digits):                {}", dbig_result.to_string());
        println!("  TwoFloat (hi+lo method):          {}", twofloat_as_dbig_100_high_prec.to_string());
        println!("  TwoFloat (legacy to_f64 method):  {}", twofloat_as_dbig_100_legacy.to_string());
        println!();
        println!("  High precision method:");
        println!("    Absolute difference:  {:.2e}", extract_f64(diff_high_prec.to_f64()));
        println!("    Relative error:       {:.2e}", rel_error_high_prec);
        println!("    Effective precision:  ~{:.1} digits", -rel_error_high_prec.log10());
        println!();
        println!("  Legacy to_f64 method:");
        println!("    Absolute difference:  {:.2e}", extract_f64(diff_legacy.to_f64()));
        println!("    Relative error:       {:.2e}", rel_error_legacy);
        println!("    Effective precision:  ~{:.1} digits", -rel_error_legacy.log10());
        println!();
        println!("  Precision improvement:  {:.1}x better", rel_error_legacy / rel_error_high_prec);
    }

    #[test]
    fn test_twofloat_e_digit_by_digit_analysis() {
        use twofloat::TwoFloat;
        use sparseir_rust::CustomNumeric;
        
        println!("TwoFloat e digit-by-digit analysis:");
        println!("===================================");
        
        // Known e value (first 50 digits)
        let e_reference = "2.718281828459045235360287471352662497757247093699959574966967627724076630353547594571382178525166427";
        let e_dbig = DBig::from_str(e_reference).unwrap().with_precision(100).unwrap();
        
        // TwoFloat calculation
        let twofloat_val = TwoFloat::from_f64(1.0);
        let twofloat_result = twofloat_val.exp();
        
        // High precision TwoFloat conversion
        let twofloat_high_prec = twofloat_to_dbig_high_precision(twofloat_result);
        let twofloat_100 = twofloat_high_prec.with_precision(100).unwrap();
        
        println!("Reference e (first 50 digits):");
        println!("{}", e_reference);
        println!();
        
        println!("TwoFloat results:");
        println!("  to_f64(): {}", twofloat_result.to_f64());
        println!("  hi:       {}", twofloat_result.hi());
        println!("  lo:       {}", twofloat_result.lo());
        println!("  hi+lo:    {}", twofloat_100.to_string());
        println!();
        
        // Convert to strings for digit-by-digit comparison
        let e_str = e_reference.replace(".", "");
        let twofloat_str = twofloat_100.to_string().replace(".", "");
        
        println!("Digit-by-digit comparison:");
        println!("Position: E vs TwoFloat");
        println!("---------+--------------");
        
        let mut first_diff_pos = None;
        let max_len = e_str.len().min(twofloat_str.len());
        
        for i in 0..max_len {
            let e_digit = e_str.chars().nth(i).unwrap_or('?');
            let tf_digit = twofloat_str.chars().nth(i).unwrap_or('?');
            
            if e_digit != tf_digit {
                if first_diff_pos.is_none() {
                    first_diff_pos = Some(i);
                }
                println!("{:8}: {} vs {}  ← DIFFERENCE", i, e_digit, tf_digit);
            } else {
                println!("{:8}: {} vs {}", i, e_digit, tf_digit);
            }
            
            // Show first 20 positions in detail
            if i >= 19 {
                println!("... (showing first 20 positions)");
                break;
            }
        }
        
        if let Some(pos) = first_diff_pos {
            println!();
            println!("First difference at position: {}", pos);
            println!("TwoFloat accuracy: {} digits", pos);
        }
        
        // Also compare with standard f64
        let f64_e = std::f64::consts::E;
        let f64_str = format!("{:.17e}", f64_e).replace(".", "").replace("e+00", "");
        
        println!();
        println!("f64 comparison:");
        println!("f64 E: {}", f64_e);
        
        let mut f64_first_diff = None;
        for i in 0..max_len.min(f64_str.len()) {
            let e_digit = e_str.chars().nth(i).unwrap_or('?');
            let f64_digit = f64_str.chars().nth(i).unwrap_or('?');
            
            if e_digit != f64_digit {
                if f64_first_diff.is_none() {
                    f64_first_diff = Some(i);
                }
            }
        }
        
        if let Some(pos) = f64_first_diff {
            println!("f64 first difference at position: {}", pos);
            println!("f64 accuracy: {} digits", pos);
        }
    }

    #[test]
    fn test_dbig_vs_exact_e_comparison() {
        println!("DBig vs exact e comparison:");
        println!("============================");
        
        // Known exact e value (first 50 digits)
        let e_exact = "2.718281828459045235360287471352662497757247093699959574966967627724076630353547594571382178525166427";
        let e_exact_dbig = DBig::from_str(e_exact).unwrap().with_precision(100).unwrap();
        
        // DBig calculated exp(1)
        let ctx_100 = Context::<HalfAway>::new(100);
        let one = f64_to_dbig(1.0).with_precision(100).unwrap();
        let dbig_exp_result = match ctx_100.exp(one.repr()) {
            Exact(result) => result,
            Inexact(result, _) => result,
        };
        
        println!("Exact e (first 50 digits):");
        println!("{}", e_exact);
        println!();
        
        println!("DBig calculated exp(1):");
        println!("{}", dbig_exp_result.to_string());
        println!();
        
        // Convert to strings for digit-by-digit comparison
        let e_exact_str = e_exact.replace(".", "");
        let dbig_str = dbig_exp_result.to_string().replace(".", "");
        
        println!("Digit-by-digit comparison (DBig vs exact e):");
        println!("Position: Exact E vs DBig");
        println!("---------+-----------------");
        
        let mut first_diff_pos = None;
        let max_len = e_exact_str.len().min(dbig_str.len());
        
        for i in 0..max_len {
            let exact_digit = e_exact_str.chars().nth(i).unwrap_or('?');
            let dbig_digit = dbig_str.chars().nth(i).unwrap_or('?');
            
            if exact_digit != dbig_digit {
                if first_diff_pos.is_none() {
                    first_diff_pos = Some(i);
                }
                println!("{:8}: {} vs {}  ← DIFFERENCE", i, exact_digit, dbig_digit);
            } else {
                println!("{:8}: {} vs {}", i, exact_digit, dbig_digit);
            }
            
            // Show first 30 positions in detail
            if i >= 29 {
                println!("... (showing first 30 positions)");
                break;
            }
        }
        
        if let Some(pos) = first_diff_pos {
            println!();
            println!("First difference at position: {}", pos);
            println!("DBig accuracy: {} digits", pos);
        } else {
            println!();
            println!("✅ DBig matches exact e perfectly within the compared range!");
        }
        
        // Calculate the difference
        let diff = (&dbig_exp_result - &e_exact_dbig).abs();
        let rel_error = if e_exact_dbig == DBig::ZERO {
            extract_f64(diff.to_f64())
        } else {
            let diff_f64 = extract_f64(diff.to_f64());
            let exact_f64 = extract_f64(e_exact_dbig.to_f64());
            diff_f64 / exact_f64.abs()
        };
        
        println!();
        println!("Numerical comparison:");
        println!("  Absolute difference:  {:.2e}", extract_f64(diff.to_f64()));
        println!("  Relative error:       {:.2e}", rel_error);
        println!("  Effective precision:  ~{:.1} digits", -rel_error.log10());
    }

    #[test]
    fn test_twofloat_exp_implementation_analysis() {
        use twofloat::TwoFloat;
        use sparseir_rust::CustomNumeric;
        
        println!("TwoFloat exp(1) implementation analysis:");
        println!("========================================");
        
        // TwoFloat calculation
        let twofloat_val = TwoFloat::from_f64(1.0);
        println!("Input: {}", twofloat_val.to_f64());
        println!("Input hi: {}", twofloat_val.hi());
        println!("Input lo: {}", twofloat_val.lo());
        println!();
        
        // Analyze the exp(1) calculation step by step
        // From the implementation:
        // x = y/2 + z where y = round(2*x) giving z <= 0.25
        // exp(x) = exp(1/2)^y * exp(z)
        
        let x = twofloat_val;
        let y = libm::round(2.0 * x.hi());
        let z = x - y / 2.0;
        
        println!("Step-by-step analysis:");
        println!("  x = {}", x.to_f64());
        println!("  y = round(2*x) = round({}) = {}", 2.0 * x.hi(), y);
        println!("  z = x - y/2 = {} - {}/2 = {}", x.to_f64(), y, z.to_f64());
        println!();
        
        // Check if z <= 0.25 as expected
        println!("Constraints check:");
        println!("  |z| = {} <= 0.25: {}", z.hi().abs(), z.hi().abs() <= 0.25);
        println!();
        
        // The actual exp calculation
        let twofloat_result = twofloat_val.exp();
        
        println!("TwoFloat exp(1) result:");
        println!("  Result: {}", twofloat_result.to_f64());
        println!("  hi: {}", twofloat_result.hi());
        println!("  lo: {}", twofloat_result.lo());
        println!();
        
        // Compare with exact e
        let exact_e = 2.718281828459045235360287471352662497757247093699959574966967627724076630353547594571382178525166427;
        let diff = (twofloat_result.to_f64() - exact_e).abs();
        let rel_error = diff / exact_e;
        
        println!("Comparison with exact e:");
        println!("  Exact e: {}", exact_e);
        println!("  TwoFloat: {}", twofloat_result.to_f64());
        println!("  Difference: {:.2e}", diff);
        println!("  Relative error: {:.2e}", rel_error);
        println!("  Accuracy: ~{:.1} digits", -rel_error.log10());
        println!();
        
        // Check if the issue is in the lookup table
        println!("Potential issues:");
        println!("  1. Lookup table precision: exp(1/2)^y values");
        println!("  2. expm1_quarter() calculation for z");
        println!("  3. Multiplication precision: exp_z * exp_y");
        println!();
        
        // Test exp(0.5) directly
        let exp_half = TwoFloat::from_f64(0.5).exp();
        let sqrt_e = exact_e.sqrt();
        let exp_half_diff = (exp_half.to_f64() - sqrt_e).abs();
        
        println!("exp(0.5) test:");
        println!("  TwoFloat exp(0.5): {}", exp_half.to_f64());
        println!("  sqrt(e): {}", sqrt_e);
        println!("  Difference: {:.2e}", exp_half_diff);
        println!("  Relative error: {:.2e}", exp_half_diff / sqrt_e);
    }

    #[test]
    fn test_twofloat_exp_precision_limitations_analysis() {
        use twofloat::TwoFloat;
        use sparseir_rust::CustomNumeric;
        
        println!("TwoFloat exp precision limitations analysis:");
        println!("============================================");
        
        // Test exp(1) step by step
        let val = TwoFloat::from_f64(1.0);
        println!("Input: {}", val.to_f64());
        println!("Input hi: {}", val.hi());
        println!("Input lo: {}", val.lo());
        println!();
        
        // Step 1: y = round(2*x)
        let y = libm::round(2.0 * val.hi());
        println!("Step 1 - y = round(2*x) = round({}) = {}", 2.0 * val.hi(), y);
        
        // Step 2: z = x - y/2
        let z = val - y / 2.0;
        println!("Step 2 - z = x - y/2 = {} - {}/2 = {}", val.to_f64(), y, z.to_f64());
        println!("  z.hi: {}", z.hi());
        println!("  z.lo: {}", z.lo());
        println!();
        
        // Step 3: exp_z = z.exp() (since expm1_quarter is private)
        let exp_z = z.exp();
        println!("Step 3 - exp_z = z.exp()");
        println!("  z.exp(): {}", exp_z.to_f64());
        println!("  exp_z.hi: {}", exp_z.hi());
        println!("  exp_z.lo: {}", exp_z.lo());
        println!();
        
        // Step 4: exp_y = exp_half(y)
        let exp_y = TwoFloat::from_f64(0.5).exp(); // This is exp(1/2)
        println!("Step 4 - exp_y = exp(1/2)^y = exp(0.5)^{}", y);
        println!("  exp(0.5): {}", exp_y.to_f64());
        println!("  exp(0.5).hi: {}", exp_y.hi());
        println!("  exp(0.5).lo: {}", exp_y.lo());
        println!();
        
        // Step 5: Final result = exp_z * exp_y
        let result = exp_z * exp_y;
        println!("Step 5 - Final result = exp_z * exp_y");
        println!("  Result: {}", result.to_f64());
        println!("  Result.hi: {}", result.hi());
        println!("  Result.lo: {}", result.lo());
        println!();
        
        // Compare with direct exp(1)
        let direct_exp = val.exp();
        println!("Direct exp(1) result:");
        println!("  Result: {}", direct_exp.to_f64());
        println!("  Result.hi: {}", direct_exp.hi());
        println!("  Result.lo: {}", direct_exp.lo());
        println!();
        
        // Check if they match
        let diff = (result - direct_exp).abs();
        println!("Step-by-step vs direct comparison:");
        println!("  Difference: {:.2e}", diff.to_f64());
        println!("  Match: {}", diff.to_f64() < 1e-30);
        println!();
        
        // Analyze the precision of each component
        let exact_e = 2.718281828459045235360287471352662497757247093699959574966967627724076630353547594571382178525166427;
        
        println!("Precision analysis:");
        println!("  Exact e: {}", exact_e);
        println!("  TwoFloat exp(1): {}", direct_exp.to_f64());
        println!("  Difference: {:.2e}", (direct_exp.to_f64() - exact_e).abs());
        println!("  Relative error: {:.2e}", (direct_exp.to_f64() - exact_e).abs() / exact_e);
        println!();
        
        // Check if the issue is in the multiplication
        println!("Multiplication precision test:");
        let a = TwoFloat::from_f64(1.0);
        let b = TwoFloat::from_f64(2.718281828459045235360287471352662497757247093699959574966967627724076630353547594571382178525166427);
        let product = a * b;
        println!("  a: {}", a.to_f64());
        println!("  b: {}", b.to_f64());
        println!("  a * b: {}", product.to_f64());
        println!("  a * b.hi: {}", product.hi());
        println!("  a * b.lo: {}", product.lo());
    }

    #[test]
    fn test_twofloat_e_constant_precision_analysis() {
        use twofloat::TwoFloat;
        use twofloat::consts::E;
        use sparseir_rust::CustomNumeric;
        
        println!("TwoFloat E constant precision analysis:");
        println!("=====================================");
        
        // TwoFloat::E constant
        println!("TwoFloat::E constant:");
        println!("  E.hi: {}", E.hi());
        println!("  E.lo: {}", E.lo());
        println!("  E.to_f64(): {}", E.to_f64());
        println!();
        
        // Exact e value
        let exact_e = 2.718281828459045235360287471352662497757247093699959574966967627724076630353547594571382178525166427;
        println!("Exact e (first 50 digits):");
        println!("{}", exact_e);
        println!();
        
        // Convert TwoFloat::E to DBig for comparison
        let e_hi_str = format!("{:.17e}", E.hi());
        let e_lo_str = format!("{:.17e}", E.lo());
        
        println!("TwoFloat::E components as strings:");
        println!("  hi: {}", e_hi_str);
        println!("  lo: {}", e_lo_str);
        println!();
        
        // Parse to DBig
        let e_hi_dbig = DBig::from_str(&e_hi_str).unwrap().with_precision(100).unwrap();
        let e_lo_dbig = DBig::from_str(&e_lo_str).unwrap().with_precision(100).unwrap();
        let e_combined = e_hi_dbig + e_lo_dbig;
        
        println!("TwoFloat::E as DBig:");
        println!("{}", e_combined.to_string());
        println!();
        
        // Compare with exact e
        let exact_e_dbig = DBig::from_str(&format!("{:.50}", exact_e)).unwrap().with_precision(100).unwrap();
        
        let diff = (&exact_e_dbig - &e_combined).abs();
        let rel_error = if exact_e_dbig == DBig::ZERO {
            extract_f64(diff.to_f64())
        } else {
            let diff_f64 = extract_f64(diff.to_f64());
            let exact_f64 = extract_f64(exact_e_dbig.to_f64());
            diff_f64 / exact_f64.abs()
        };
        
        println!("Precision comparison:");
        println!("  Exact e:      {}", exact_e_dbig.to_string());
        println!("  TwoFloat::E:  {}", e_combined.to_string());
        println!("  Difference:   {:.2e}", extract_f64(diff.to_f64()));
        println!("  Relative error: {:.2e}", rel_error);
        println!("  Accuracy: ~{:.1} digits", -rel_error.log10());
        println!();
        
        // Check if TwoFloat::E matches exp(1) calculation
        let exp_one = TwoFloat::from_f64(1.0).exp();
        let exp_one_hi_str = format!("{:.17e}", exp_one.hi());
        let exp_one_lo_str = format!("{:.17e}", exp_one.lo());
        
        let exp_one_hi_dbig = DBig::from_str(&exp_one_hi_str).unwrap().with_precision(100).unwrap();
        let exp_one_lo_dbig = DBig::from_str(&exp_one_lo_str).unwrap().with_precision(100).unwrap();
        let exp_one_combined = exp_one_hi_dbig + exp_one_lo_dbig;
        
        println!("TwoFloat::exp(1) calculation:");
        println!("  exp(1).hi: {}", exp_one.hi());
        println!("  exp(1).lo: {}", exp_one.lo());
        println!("  exp(1) combined: {}", exp_one_combined.to_string());
        println!();
        
        // Compare TwoFloat::E vs TwoFloat::exp(1)
        let e_vs_exp_diff = (&e_combined - &exp_one_combined).abs();
        let e_vs_exp_rel_error = if e_combined == DBig::ZERO {
            extract_f64(e_vs_exp_diff.to_f64())
        } else {
            let diff_f64 = extract_f64(e_vs_exp_diff.to_f64());
            let e_f64 = extract_f64(e_combined.to_f64());
            diff_f64 / e_f64.abs()
        };
        
        println!("TwoFloat::E vs TwoFloat::exp(1) comparison:");
        println!("  TwoFloat::E:    {}", e_combined.to_string());
        println!("  TwoFloat::exp(1): {}", exp_one_combined.to_string());
        println!("  Difference:     {:.2e}", extract_f64(e_vs_exp_diff.to_f64()));
        println!("  Relative error: {:.2e}", e_vs_exp_rel_error);
        println!("  Match: {}", e_vs_exp_rel_error < 1e-30);
    }

    #[test]
    fn test_twofloat_high_precision_conversion_methods() {
        use twofloat::TwoFloat;
        use sparseir_rust::CustomNumeric;
        
        println!("TwoFloat high precision conversion methods test:");
        println!("================================================");
        
        // DBig reference (100 digits precision)
        let ctx_100 = Context::<HalfAway>::new(100);
        let val = 1.0;
        let dbig_val = f64_to_dbig(val);
        let dbig_100 = dbig_val.with_precision(100).unwrap();
        let dbig_result = match ctx_100.exp(dbig_100.repr()) {
            Exact(result) => result,
            Inexact(result, _) => result,
        };
        
        // TwoFloat calculation
        let twofloat_val = TwoFloat::from_f64(val);
        let twofloat_result = twofloat_val.exp();
        
        println!("Reference values:");
        println!("  DBig exp(1): {}", dbig_result.to_string());
        println!("  TwoFloat exp(1): {}", twofloat_result.to_f64());
        println!();
        
        // Test different conversion methods
        let methods = [
            ("Legacy to_f64", twofloat_to_dbig(twofloat_result)),
            ("High precision hi+lo", twofloat_to_dbig_high_precision(twofloat_result)),
            ("Ultra precision", twofloat_to_dbig_ultra_precision(twofloat_result)),
        ];
        
        println!("Conversion method comparison:");
        println!("Method                | Result                                    | Diff vs DBig    | Rel Error");
        println!("----------------------|-------------------------------------------|-----------------|----------");
        
        for (name, converted) in methods {
            let converted_100 = converted.with_precision(100).unwrap();
            let diff = (&dbig_result - &converted_100).abs();
            let rel_error = if dbig_result == DBig::ZERO {
                extract_f64(diff.to_f64())
            } else {
                let diff_f64 = extract_f64(diff.to_f64());
                let dbig_f64 = extract_f64(dbig_result.to_f64());
                diff_f64 / dbig_f64.abs()
            };
            
            println!("{:20} | {:41} | {:.2e} | {:.2e}", 
                     name, 
                     converted_100.to_string().chars().take(41).collect::<String>(),
                     extract_f64(diff.to_f64()),
                     rel_error);
        }
        
        println!();
        
        // Test with different input values
        let test_values = [0.5, 1.0, 2.0, -1.0, 0.1];
        
        println!("Testing different input values:");
        println!("Input | Method                | Rel Error vs DBig");
        println!("------|-----------------------|------------------");
        
        for input_val in test_values {
            let dbig_input = f64_to_dbig(input_val).with_precision(100).unwrap();
            let dbig_exp = match ctx_100.exp(dbig_input.repr()) {
                Exact(result) => result,
                Inexact(result, _) => result,
            };
            
            let tf_input = TwoFloat::from_f64(input_val);
            let tf_exp = tf_input.exp();
            
            let ultra_converted = twofloat_to_dbig_ultra_precision(tf_exp);
            let ultra_100 = ultra_converted.with_precision(100).unwrap();
            
            let diff = (&dbig_exp - &ultra_100).abs();
            let rel_error = if dbig_exp == DBig::ZERO {
                extract_f64(diff.to_f64())
            } else {
                let diff_f64 = extract_f64(diff.to_f64());
                let dbig_f64 = extract_f64(dbig_exp.to_f64());
                diff_f64 / dbig_f64.abs()
            };
            
            println!("{:5} | Ultra precision      | {:.2e}", input_val, rel_error);
        }
    }
}