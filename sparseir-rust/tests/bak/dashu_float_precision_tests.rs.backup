//! High-precision arithmetic tests using dashu-float
//!
//! This test module validates the precision and accuracy of dashu-float operations
//! by comparing results with f64 and TwoFloat computations.

#[cfg(test)]
mod dashu_float_precision_tests {
    use dashu_float::{DBig, Context};
    use dashu_float::round::mode::HalfAway;
    use dashu_base::{Abs, Approximation, Approximation::*};
    use twofloat::TwoFloat;
    use std::str::FromStr;

    // Test configuration
    const HIGH_PRECISION_DIGITS: usize = 50;
    const MEDIUM_PRECISION_DIGITS: usize = 20;
    const TOLERANCE_F64: f64 = 1e-15;
    const TOLERANCE_TWOFLOAT: f64 = 1e-30;
    const TOLERANCE_TWOFLOAT_VS_DBIG: f64 = 1e-11; // TwoFloat vs DBig comparison tolerance (TwoFloat precision limit)

    /// Helper function to create high-precision context
    fn high_precision_ctx() -> Context<HalfAway> {
        Context::<HalfAway>::new(HIGH_PRECISION_DIGITS)
    }

    /// Helper function to convert f64 to high-precision DBig
    fn f64_to_dbig(val: f64) -> DBig {
        // Convert f64 to string first, then to DBig to preserve precision
        let val_str = format!("{}", val);
        DBig::from_str(&val_str)
            .unwrap()
            .with_precision(HIGH_PRECISION_DIGITS)
            .unwrap()
    }

    /// Helper function to convert TwoFloat to high-precision DBig
    fn twofloat_to_dbig(val: TwoFloat) -> DBig {
        // Convert TwoFloat to f64 first, then to string
        let f64_val: f64 = val.into();
        let val_str = format!("{}", f64_val);
        DBig::from_str(&val_str)
            .unwrap()
            .with_precision(HIGH_PRECISION_DIGITS)
            .unwrap()
    }

    /// Helper function to convert TwoFloat directly to DBig (preserving maximum precision)
    fn twofloat_to_dbig_direct(val: TwoFloat) -> DBig {
        // TwoFloat stores value as sum of two f64s for higher precision
        // Extract the high-precision representation directly
        let f64_val: f64 = val.into();
        
        // Use maximum precision string representation
        let val_str = format!("{:.17e}", f64_val); // 17 digits for TwoFloat's precision
        DBig::from_str(&val_str)
            .unwrap()
            .with_precision(HIGH_PRECISION_DIGITS)
            .unwrap()
    }

    /// Helper function to extract f64 from Approximation
    fn extract_f64(approx: Approximation<f64, dashu_float::round::Rounding>) -> f64 {
        match approx {
            Exact(val) => val,
            Inexact(val, _) => val,
        }
    }

    /// Helper function to calculate relative error
    fn relative_error(actual: f64, expected: f64) -> f64 {
        if expected == 0.0 {
            actual.abs() // If expected is 0, return absolute error
        } else {
            (actual - expected).abs() / expected.abs()
        }
    }

    // ============================================================================
    // BASIC CONVERSION TESTS
    // ============================================================================

    #[test]
    fn test_f64_to_dbig_conversion() {
        let test_values = vec![
            0.0,
            1.0,
            -1.0,
            3.141592653589793,
            -2.718281828459045,
            42.0,
            1e-10,
            1e10,
        ];

        for &val in &test_values {
            let dbig_val = f64_to_dbig(val);
            let back_to_f64 = extract_f64(dbig_val.to_f64());
            
            println!("f64: {} -> DBig: {} -> f64: {}", val, dbig_val, back_to_f64);
            
            // Should be very close (within machine precision)
            let diff = (val - back_to_f64).abs();
            assert!(diff < TOLERANCE_F64, 
                "f64 conversion error: {} vs {}, diff: {}", val, back_to_f64, diff);
        }
    }

    #[test]
    fn test_twofloat_to_dbig_conversion() {
        let test_values = vec![
            TwoFloat::new_add(3.141592653589793, 1.0e-16),
            TwoFloat::new_add(2.718281828459045, -1.0e-17),
            TwoFloat::new_add(42.0, 1.0e-15),
            TwoFloat::new_add(0.0, 1.0e-20), // Very small value
        ];

        for &tf_val in &test_values {
            let dbig_val = twofloat_to_dbig(tf_val);
            let tf_as_f64: f64 = tf_val.into();
            
            println!("TwoFloat: {} -> DBig: {}", tf_as_f64, dbig_val);
            
            // TwoFloat precision should be preserved
            assert!(dbig_val.precision() >= HIGH_PRECISION_DIGITS);
        }
    }

    // ============================================================================
    // MATHEMATICAL FUNCTION TESTS
    // ============================================================================

    #[test]
    fn test_exp_function_precision() {
        let ctx = high_precision_ctx();
        let test_values = vec![0.0, 1.0, -1.0, 0.5, -0.5, 2.0, -2.0];

        for &val in &test_values {
            // TwoFloat computation
            let tf_val = TwoFloat::from(val);
            let tf_result = tf_val.exp();
            
            // DBig high-precision computation
            let dbig_val = f64_to_dbig(val);
            let dbig_result = match ctx.exp(dbig_val.repr()) {
                Exact(result) => result,
                Inexact(result, _) => result,
            };
            
            // Convert TwoFloat directly to DBig for proper comparison
            let tf_as_dbig = twofloat_to_dbig_direct(tf_result);
            
            // Calculate relative error in DBig precision
            let diff = (&dbig_result - &tf_as_dbig).abs();
            let rel_error = if dbig_result == DBig::ZERO {
                extract_f64(diff.to_f64())
            } else {
                let diff_f64 = extract_f64(diff.to_f64());
                let dbig_f64 = extract_f64(dbig_result.to_f64());
                diff_f64 / dbig_f64.abs()
            };
            
            // For display, convert TwoFloat and DBig to f64
            let tf_as_f64: f64 = tf_result.into();
            let dbig_as_f64 = extract_f64(dbig_result.to_f64());
            println!("exp({}): TwoFloat={:.15e}, DBig={:.15e}, rel_error={:.2e}", 
                     val, tf_as_f64, dbig_as_f64, rel_error);
            
            // Special analysis for problematic values
            if val == -1.0 {
                println!("  Debug exp(-1):");
                println!("    TwoFloat result: {:.20e}", tf_as_f64);
                println!("    DBig result: {:.20e}", dbig_as_f64);
                println!("    Relative error: {:.20e}", rel_error);
                println!("    Tolerance: {:.20e}", TOLERANCE_TWOFLOAT_VS_DBIG);
            }
            
            // Results should be very close (TwoFloat has limited precision)
            assert!(rel_error < TOLERANCE_TWOFLOAT_VS_DBIG, 
                "exp({}) relative error too large: TwoFloat={:.15e}, DBig={:.15e}, rel_error={:.2e}", 
                val, tf_as_f64, dbig_as_f64, rel_error);
        }
    }

    #[test]
    fn test_ln_function_precision() {
        let ctx = high_precision_ctx();
        let test_values = vec![1.0, 2.718281828459045, 10.0, 0.5, 0.1];

        for &val in &test_values {
            // TwoFloat computation
            let tf_val = TwoFloat::from(val);
            let tf_result = tf_val.ln();
            
            // DBig high-precision computation
            let dbig_val = f64_to_dbig(val);
            let dbig_result = match ctx.ln(dbig_val.repr()) {
                Exact(result) => result,
                Inexact(result, _) => result,
            };
            
            // Convert TwoFloat directly to DBig for proper comparison
            let tf_as_dbig = twofloat_to_dbig_direct(tf_result);
            
            // Calculate relative error in DBig precision
            let diff = (&dbig_result - &tf_as_dbig).abs();
            let rel_error = if dbig_result == DBig::ZERO {
                extract_f64(diff.to_f64())
            } else {
                let diff_f64 = extract_f64(diff.to_f64());
                let dbig_f64 = extract_f64(dbig_result.to_f64());
                diff_f64 / dbig_f64.abs()
            };
            
            // For display, convert TwoFloat and DBig to f64
            let tf_as_f64: f64 = tf_result.into();
            let dbig_as_f64 = extract_f64(dbig_result.to_f64());
            println!("ln({}): TwoFloat={:.15e}, DBig={:.15e}, rel_error={:.2e}", 
                     val, tf_as_f64, dbig_as_f64, rel_error);
            
            // Results should be very close (TwoFloat has limited precision)
            assert!(rel_error < TOLERANCE_TWOFLOAT_VS_DBIG, 
                "ln({}) relative error too large: TwoFloat={:.15e}, DBig={:.15e}, rel_error={:.2e}", 
                val, tf_as_f64, dbig_as_f64, rel_error);
        }
    }

    #[test]
    fn test_sqrt_function_precision() {
        let ctx = high_precision_ctx();
        let test_values = vec![1.0, 4.0, 9.0, 0.25, 0.01, 2.0, 3.0];

        for &val in &test_values {
            // TwoFloat computation
            let tf_val = TwoFloat::from(val);
            let tf_result = tf_val.sqrt();
            
            // DBig high-precision computation
            let dbig_val = f64_to_dbig(val);
            let dbig_result = match ctx.sqrt(dbig_val.repr()) {
                Exact(result) => result,
                Inexact(result, _) => result,
            };
            
            // Convert TwoFloat directly to DBig for proper comparison
            let tf_as_dbig = twofloat_to_dbig_direct(tf_result);
            
            // Calculate relative error in DBig precision
            let diff = (&dbig_result - &tf_as_dbig).abs();
            let rel_error = if dbig_result == DBig::ZERO {
                extract_f64(diff.to_f64())
            } else {
                let diff_f64 = extract_f64(diff.to_f64());
                let dbig_f64 = extract_f64(dbig_result.to_f64());
                diff_f64 / dbig_f64.abs()
            };
            
            // For display, convert TwoFloat and DBig to f64
            let tf_as_f64: f64 = tf_result.into();
            let dbig_as_f64 = extract_f64(dbig_result.to_f64());
            println!("sqrt({}): TwoFloat={:.15e}, DBig={:.15e}, rel_error={:.2e}", 
                     val, tf_as_f64, dbig_as_f64, rel_error);
            
            // Results should be very close (TwoFloat has limited precision)
            assert!(rel_error < TOLERANCE_TWOFLOAT_VS_DBIG, 
                "sqrt({}) relative error too large: TwoFloat={:.15e}, DBig={:.15e}, rel_error={:.2e}", 
                val, tf_as_f64, dbig_as_f64, rel_error);
        }
    }

    // ============================================================================
    // SPARSEIR-LIKE KERNEL CALCULATION TESTS
    // ============================================================================

    #[test]
    fn test_kernel_calculation_exp_minus_lambda() {
        let ctx = high_precision_ctx();
        let lambda_values = vec![10.0, 42.0, 10000.0];
        let x_values = vec![0.1, 0.5, 0.9];
        let y_values = vec![0.2, 0.4, 0.8];

        for &lambda in &lambda_values {
            for &x in &x_values {
                for &y in &y_values {
                    // Calculate exp(-lambda * |x - y|)
                    
                    // TwoFloat computation
                    let tf_lambda = TwoFloat::from(lambda);
                    let tf_x = TwoFloat::from(x);
                    let tf_y = TwoFloat::from(y);
                    
                    let tf_diff = (tf_x - tf_y).abs();
                    let tf_exponent = -tf_lambda * tf_diff;
                    let tf_kernel = tf_exponent.exp();
                    
                    // DBig high-precision computation
                    let dbig_lambda = f64_to_dbig(lambda);
                    let dbig_x = f64_to_dbig(x);
                    let dbig_y = f64_to_dbig(y);
                    
                    let dbig_diff = (&dbig_x - &dbig_y).abs();
                    let dbig_exponent = -&dbig_lambda * &dbig_diff;
                    
                    let dbig_kernel = match ctx.exp(dbig_exponent.repr()) {
                        Exact(result) => result,
                        Inexact(result, _) => result,
                    };
                    
                    // Convert TwoFloat directly to DBig for proper comparison
                    let tf_kernel_dbig = twofloat_to_dbig_direct(tf_kernel);
                    
                    // Calculate relative error in DBig precision
                    let diff = (&dbig_kernel - &tf_kernel_dbig).abs();
                    let rel_error = if dbig_kernel == DBig::ZERO {
                        extract_f64(diff.to_f64())
                    } else {
                        let diff_f64 = extract_f64(diff.to_f64());
                        let dbig_f64 = extract_f64(dbig_kernel.to_f64());
                        diff_f64 / dbig_f64.abs()
                    };
                    
                    // For display, convert TwoFloat and DBig to f64
                    let tf_kernel_f64: f64 = tf_kernel.into();
                    let dbig_kernel_f64 = extract_f64(dbig_kernel.to_f64());
                    println!("Kernel(λ={}, x={}, y={}): TwoFloat={:.15e}, DBig={:.15e}, rel_error={:.2e}", 
                             lambda, x, y, tf_kernel_f64, dbig_kernel_f64, rel_error);
                    
                    // Results should be very close (TwoFloat has limited precision)
                    assert!(rel_error < TOLERANCE_TWOFLOAT_VS_DBIG, 
                        "Kernel calculation error: λ={}, x={}, y={}, rel_error={:.2e}", 
                        lambda, x, y, rel_error);
                }
            }
        }
    }

    // ============================================================================
    // TWOFLOAT COMPARISON TESTS
    // ============================================================================

    #[test]
    fn test_twofloat_vs_dbig_precision() {
        let test_cases = vec![
            (3.141592653589793, 1.0e-16),
            (2.718281828459045, -1.0e-17),
            (42.0, 1.0e-15),
            (0.1, 1.0e-18),
        ];

        for &(hi, lo) in &test_cases {
            let tf_val = TwoFloat::new_add(hi, lo);
            let tf_as_f64: f64 = tf_val.into();
            
            // TwoFloat to DBig
            let dbig_val = twofloat_to_dbig(tf_val);
            
            // DBig back to f64 for comparison
            let dbig_as_f64 = extract_f64(dbig_val.to_f64());
            
            println!("TwoFloat: {} -> DBig: {} -> f64: {}", 
                     tf_as_f64, dbig_val, dbig_as_f64);
            
            // The conversion should preserve as much precision as possible
            let diff: f64 = (tf_as_f64 - dbig_as_f64).abs();
            
            println!("TwoFloat as f64: {:.15e}, difference: {:.2e}", tf_as_f64, diff);
            
            // For very small differences, we expect good preservation
            if lo.abs() > 1e-18 {
                assert!(diff < TOLERANCE_TWOFLOAT, 
                    "TwoFloat precision loss: original={:.15e}, converted={:.15e}, diff={:.2e}", 
                    tf_as_f64, dbig_as_f64, diff);
            }
        }
    }

    #[test]
    fn test_dbig_precision_analysis() {
        let ctx = high_precision_ctx();
        
        // Test exp(-1) with different precision settings
        let val = -1.0;
        let dbig_val = f64_to_dbig(val);
        
        println!("DBig precision analysis for exp(-1):");
        println!("=====================================");
        println!("Input value: {}", dbig_val);
        
        let dbig_result = match ctx.exp(dbig_val.repr()) {
            Exact(result) => result,
            Inexact(result, _) => result,
        };
        
        println!("DBig result (raw): {}", dbig_result);
        println!("DBig result (string): {}", dbig_result.to_string());
        
        // Test with different precision settings
        for precision in [20, 30, 40, 50, 60] {
            let dbig_high_precision = dbig_val.clone().with_precision(precision).unwrap();
            let dbig_result_high = match ctx.exp(dbig_high_precision.repr()) {
                Exact(result) => result,
                Inexact(result, _) => result,
            };
            
            println!("{} digits: {}", precision, dbig_result_high.to_string());
        }
        
        // Compare with Julia BigFloat reference
        println!("\nComparison with Julia BigFloat:");
        println!("Julia 50 digits:  0.36787944117144233");
        println!("Julia 200 digits: 0.36787944117144232159552377016146086744581113103176783450783671");
    }

    // ============================================================================
    // PRECISION LIMIT TESTS
    // ============================================================================

    #[test]
    fn test_precision_limits() {
        let test_val = DBig::from_str("3.14159265358979323846264338327950288419716939937510").unwrap();
        
        // Test different precision levels
        let precision_levels = vec![5, 10, 20, 50, 100];
        
        for precision in precision_levels {
            let result = test_val.clone().with_precision(precision);
            match &result {
                Exact(val) => println!("Precision {}: Exact -> {}", precision, val),
                Inexact(val, _) => println!("Precision {}: Inexact -> {}", precision, val),
            }
            
            // Verify precision is set correctly
            match &result {
                Exact(val) | Inexact(val, _) => {
                    assert!(val.precision() <= precision, 
                        "Precision {} exceeded limit {}", val.precision(), precision);
                }
            }
        }
    }

    // ============================================================================
    // ERROR HANDLING TESTS
    // ============================================================================

    #[test]
    fn test_invalid_conversions() {
        // Test conversion of special values
        let special_values = vec![f64::INFINITY, f64::NEG_INFINITY, f64::NAN];
        
        for &val in &special_values {
            // Use string conversion for special values
            let result = if val.is_nan() {
                Err(dashu_base::ConversionError::OutOfBounds)
            } else if val.is_infinite() {
                Ok(if val > 0.0 { DBig::INFINITY } else { DBig::NEG_INFINITY })
            } else {
                Ok(DBig::from_str(&format!("{}", val)).unwrap())
            };
            
            match result {
                Ok(dbig_val) => {
                    println!("Special value {} converted to: {}", val, dbig_val);
                    // Infinity should be handled
                    if val.is_infinite() {
                        // Check if it's infinity (DBig has is_infinite method)
                        let is_inf = dbig_val == DBig::INFINITY || dbig_val == DBig::NEG_INFINITY;
                        assert!(is_inf, "Expected infinity, got: {}", dbig_val);
                    }
                }
                Err(e) => {
                    println!("Special value {} conversion failed: {:?}", val, e);
                    // NaN should fail
                    if val.is_nan() {
                        // This is expected
                    }
                }
            }
        }
    }
}
