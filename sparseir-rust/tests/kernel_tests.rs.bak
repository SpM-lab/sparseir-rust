//! Integration tests for sparseir-rust
//!
//! These tests verify that the public API works correctly and that
//! different modules work together properly.

use sparseir_rust::*;
use twofloat::TwoFloat;
use dashu_float::{DBig, Context};
use dashu_float::round::mode::HalfAway;
use dashu_base::{Abs, Approximation, Approximation::*};

fn f64_to_dbig(val: f64, precision: usize) -> DBig {
    // Convert f64 to string first, then to DBig to preserve precision
    let val_str = format!("{:34}", val);
    DBig::from_str(&val_str)
        .unwrap()
        .with_precision(precision)
        .unwrap()
}

fn check_centrosymmkernel<K: CentrosymmKernel>(kernel: K){
    for x in [-1.0, 0.0, 1.0] {
        for y in [-1.0, 0.0, 1.0] {
            let kval_tf = kernel.compute(TwoFloat::from(x), TwoFloat::from(y));
            let kval = kernel.compute_f64(x, y);
            assert!(((kval - kval_tf)).abs() < 1e-16);

            let kval_tf_symm = kernel.compute(-TwoFloat::from(x), -TwoFloat::from(y));
            assert!(((kval_tf_symm - kval_tf)).abs() < 1e-14); //FIXME: too loose;
        }
    }
}

#[test]
fn test_logistic_kernel() {
    // Test that kernels work with different statistics types
    let kernel = LogisticKernel::new(10.0);
    
    check_centrosymmkernel(kernel);

    //let ctx = Context::<HalfAway>::new(100);
    //for x in [-1.0, 0.0, 1.0] {
        //for y in [-1.0, 0.0, 1.0] {
            //let kval_tf = kernel.compute(TwoFloat::from(x), TwoFloat::from(y));
            //let kval_tf_symm = kernel.compute(-TwoFloat::from(x), -TwoFloat::from(y));
            ////assert!(((kval_tf_symm - kval_tf)).abs() < 1e-14); //FIXME: too loose;
        //}
    //}
}