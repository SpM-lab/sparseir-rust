//! Tests for SVE module

use sparseir_rust::*;
use std::sync::Arc;

#[test]
fn test_twork_type_values() {
    // Test that enum values match C-API constants
    assert_eq!(sve::TworkType::Float64 as i32, 0);
    assert_eq!(sve::TworkType::Float64X2 as i32, 1);
    assert_eq!(sve::TworkType::Auto as i32, -1);
}

#[test]
fn test_svd_strategy_values() {
    // Test that enum values match C-API constants
    assert_eq!(sve::SVDStrategy::Fast as i32, 0);
    assert_eq!(sve::SVDStrategy::Accurate as i32, 1);
    assert_eq!(sve::SVDStrategy::Auto as i32, -1);
}

#[test]
fn test_compute_sve_placeholder() {
    // Test the placeholder compute_sve function
    let kernel = kernel::LogisticKernel::new(1.0);
    let epsilon = 1e-12;
    
    // For now, just test that the function compiles and runs
    // The actual SVD computation requires BLAS which is not available in test environment
    let _result = sve::compute_sve(
        kernel,
        epsilon,
        Some(1e-10),
        Some(10),
        Some(20),
        sve::TworkType::Float64,
    );
    
    // Basic checks - the function should not panic
    assert!(true);
}

#[test]
fn test_sveresult_creation() {
    // Create dummy polynomials for testing
    let dummy_poly = poly::PiecewiseLegendrePoly::new(
        ndarray::Array2::zeros((1, 1)),
        vec![0.0, 1.0],
        0,
        None,
        0
    );
    
    let u = poly::PiecewiseLegendrePolyVector::new(vec![dummy_poly.clone()]);
    let s = ndarray::Array1::from_vec(vec![1.0]);
    let v = poly::PiecewiseLegendrePolyVector::new(vec![dummy_poly]);
    
    // Create SVEResult
    let sve_result = sve::SVEResult::new(u.clone(), s.clone(), v.clone(), 1e-12);
    
    // Test basic properties
    assert_eq!(sve_result.epsilon, 1e-12);
    assert_eq!(sve_result.s.len(), 1);
    assert_eq!(sve_result.u.get_polys().len(), 1);
    assert_eq!(sve_result.v.get_polys().len(), 1);
    
    // Test part method with no truncation
    let (u_part, s_part, v_part) = sve_result.part(Some(1e-15), None);
    assert_eq!(s_part.len(), 1);
    assert_eq!(u_part.get_polys().len(), 1);
    assert_eq!(v_part.get_polys().len(), 1);
}

#[test]
fn test_sampling_sve_creation() {
    // Test SamplingSVE creation
    let kernel = Arc::new(kernel::LogisticKernel::new(1.0));
    let hints = kernel.sve_hints::<f64>(1e-12);
    let _sve = sve::SamplingSVE::new(*kernel, hints, 1e-12, Some(10));
    
    // Basic check that it was created successfully
    // (No public fields to test, but creation should not panic)
    assert!(true);
}

/* 
#[test]
fn test_centrosymm_sve_creation() {
    // Test CentrosymmSVE creation
    let kernel = Arc::new(kernel::LogisticKernel::new(1.0));
    let hints = kernel.sve_hints::<f64>(1e-12);
    let _sve = sve::CentrosymmSVE::new(*kernel, hints, 1e-12, Some(10));
    
    // Basic check that it was created successfully
    // (No public fields to test, but creation should not panic)
    assert!(true);
}

#[test]
fn test_symmetrized_kernel_basic() {
    use sparseir_rust::kernel::{LogisticKernel, SymmetrizedKernel};
    use twofloat::TwoFloat;
    
    let lambda = 5.0;
    let kernel = LogisticKernel::new(lambda);
    
    // Test symmetrized kernels
    let even_kernel = SymmetrizedKernel::new(kernel.clone(), 1);
    let odd_kernel = SymmetrizedKernel::new(kernel.clone(), -1);
    
    // Test some evaluation points
    let test_points = vec![(0.1, 0.2), (0.5, -0.3), (-0.7, 0.4)];
    
    for (x, y) in test_points {
        let x_twofloat = TwoFloat::from(x);
        let y_twofloat = TwoFloat::from(y);
        
        let original_val = kernel.compute(x_twofloat, y_twofloat);
        let even_val = even_kernel.compute(x_twofloat, y_twofloat);
        let odd_val = odd_kernel.compute(x_twofloat, y_twofloat);
        
        
        // Even: K(x,+y) + K(x,-y) (C++ callreduced implementation)
        let neg_y = TwoFloat::from(-y);
        let neg_val = kernel.compute(x_twofloat, neg_y);
        let expected_even = original_val + neg_val;
        
        // Odd: K(x,+y) - K(x,-y) (C++ callreduced implementation)
        let expected_odd = original_val - neg_val;
        
        let even_diff = (even_val - expected_even).abs();
        let odd_diff = (odd_val - expected_odd).abs();
        
        assert!(even_diff < 1e-14, "Even symmetry error: {} vs {}", even_val, expected_even);
        assert!(odd_diff < 1e-14, "Odd symmetry error: {} vs {}", odd_val, expected_odd);
    }
    
}

#[test]
fn test_symmetrized_kernel_domain_reduction() {
    use sparseir_rust::kernel::{LogisticKernel, SymmetrizedKernel};
    
    let lambda = 5.0;
    let kernel = LogisticKernel::new(lambda);
    
    // Test symmetrized kernels
    let even_kernel = SymmetrizedKernel::new(kernel.clone(), 1);
    let odd_kernel = SymmetrizedKernel::new(kernel.clone(), -1);
    
    let epsilon = 1e-12;
    
    // Get SVE hints
    let original_hints = kernel.sve_hints::<f64>(epsilon);
    let even_hints = even_kernel.sve_hints::<f64>(epsilon);
    let odd_hints = odd_kernel.sve_hints::<f64>(epsilon);
    
    // Check segments
    let original_segments_x = original_hints.segments_x();
    let original_segments_y = original_hints.segments_y();
    let even_segments_x = even_hints.segments_x();
    let even_segments_y = even_hints.segments_y();
    let odd_segments_x = odd_hints.segments_x();
    let odd_segments_y = odd_hints.segments_y();
    
    
    // Check that symmetrized kernels have fewer segments (domain reduction)
    assert!(even_segments_x.len() < original_segments_x.len(), 
            "Even segments_x should have fewer segments: {} vs {}", 
            even_segments_x.len(), original_segments_x.len());
    assert!(even_segments_y.len() < original_segments_y.len(),
            "Even segments_y should have fewer segments: {} vs {}",
            even_segments_y.len(), original_segments_y.len());
    assert!(odd_segments_x.len() < original_segments_x.len(),
            "Odd segments_x should have fewer segments: {} vs {}",
            odd_segments_x.len(), original_segments_x.len());
    assert!(odd_segments_y.len() < original_segments_y.len(),
            "Odd segments_y should have fewer segments: {} vs {}",
            odd_segments_y.len(), original_segments_y.len());
    
    // Check that symmetrized segments only contain positive values
    for &x in &even_segments_x {
        assert!(x >= 0.0, "Even segments_x should only contain positive values, got {}", x);
    }
    for &y in &even_segments_y {
        assert!(y >= 0.0, "Even segments_y should only contain positive values, got {}", y);
    }
    for &x in &odd_segments_x {
        assert!(x >= 0.0, "Odd segments_x should only contain positive values, got {}", x);
    }
    for &y in &odd_segments_y {
        assert!(y >= 0.0, "Odd segments_y should only contain positive values, got {}", y);
    }
    
    // Check nsvals reduction
    let original_nsvals = original_hints.nsvals();
    let even_nsvals = even_hints.nsvals();
    let odd_nsvals = odd_hints.nsvals();
    
    
    // Check that nsvals is approximately halved
    assert!(even_nsvals <= (original_nsvals + 1) / 2,
            "Even nsvals should be approximately halved: {} vs {}", 
            even_nsvals, original_nsvals);
    assert!(odd_nsvals <= (original_nsvals + 1) / 2,
            "Odd nsvals should be approximately halved: {} vs {}",
            odd_nsvals, original_nsvals);
    
}
            */

#[test]
fn test_centrosymm_vs_sampling_equivalence() {
    use sparseir_rust::kernel::{LogisticKernel, TestNonCentrosymmKernel};
    use sparseir_rust::sve::{SamplingSVE, CentrosymmSVE};
    
    // Create test kernel that returns same values as LogisticKernel but is not centrosymmetric
    let lambda = 5.0;
    let test_kernel = TestNonCentrosymmKernel::new(lambda);
    let logistic_kernel = LogisticKernel::new(lambda);
    
    // Verify that test kernel is not centrosymmetric
    assert!(!test_kernel.is_centrosymmetric());
    assert!(logistic_kernel.is_centrosymmetric());
    
    // Verify that both kernels return the same values for some test points
    let test_points = vec![(0.1, 0.2), (0.5, -0.3), (-0.7, 0.4)];
    for (x, y) in test_points {
        use twofloat::TwoFloat;
        let x_twofloat = TwoFloat::from(x);
        let y_twofloat = TwoFloat::from(y);
        let test_val = test_kernel.compute(x_twofloat, y_twofloat);
        let logistic_val = logistic_kernel.compute(x_twofloat, y_twofloat);
        let diff = (test_val - logistic_val).abs();
        assert!(diff < 1e-15, 
                "Kernels should return same values at ({}, {}): test_val={}, logistic_val={}, diff={}", x, y, test_val, logistic_val, diff);
    }
    
    let epsilon = 1e-12;
    let n_gauss = Some(10);
    
    // Create SVE hints for both kernels
    let test_hints = test_kernel.sve_hints::<f64>(epsilon);
    let logistic_hints = logistic_kernel.sve_hints::<f64>(epsilon);
    
    // Create CentrosymmSVE with test kernel (should behave like SamplingSVE)
    let centrosymm_sve = CentrosymmSVE::new(test_kernel.clone(), test_hints.clone(), epsilon, n_gauss);
    
    // Create SamplingSVE with test kernel
    let sampling_sve = SamplingSVE::new(test_kernel.clone(), test_hints.clone(), epsilon, n_gauss);
    
    // Create SamplingSVE with LogisticKernel (should be equivalent to CentrosymmSVE)
    let logistic_sampling_sve = SamplingSVE::new(logistic_kernel.clone(), logistic_hints.clone(), epsilon, n_gauss);
    
    // Get matrices from each SVE method
    let centrosymm_matrices = centrosymm_sve.matrices();
    let sampling_matrices = sampling_sve.matrices();
    let logistic_matrices = logistic_sampling_sve.matrices();
    
    // CentrosymmSVE should return 2 matrices (even and odd)
    assert_eq!(centrosymm_matrices.len(), 2, "CentrosymmSVE should return 2 matrices (even and odd)");
    assert_eq!(sampling_matrices.len(), 1, "SamplingSVE should return 1 matrix");
    assert_eq!(logistic_matrices.len(), 1, "LogisticKernel SamplingSVE should return 1 matrix");
    
    // Check matrix dimensions
    
    // Note: even_sve and odd_sve fields are private, so we can't access them directly
    // The current implementation only returns even matrices from matrices() method
    
    // For centrosymmetric decomposition, matrices should have reduced size
    // CentrosymmSVE uses reduced domain [0, 1] instead of [-1, 1], so matrices are smaller
    let centrosymm_rows = centrosymm_matrices[0].shape()[0];
    let centrosymm_cols = centrosymm_matrices[0].shape()[1];
    let sampling_rows = sampling_matrices[0].shape()[0];
    let sampling_cols = sampling_matrices[0].shape()[1];
    
    // CentrosymmSVE matrices should be approximately half the size due to domain reduction
    assert!(centrosymm_rows < sampling_rows, 
            "CentrosymmSVE rows should be smaller: {} vs {}", centrosymm_rows, sampling_rows);
    assert!(centrosymm_cols < sampling_cols,
            "CentrosymmSVE cols should be smaller: {} vs {}", centrosymm_cols, sampling_cols);
    
    // SamplingSVE matrices should be the same for same kernel
    assert_eq!(sampling_matrices[0].shape(), logistic_matrices[0].shape(),
               "SamplingSVE matrices should have same shape for same kernel");
    
    // Compute SVD for each matrix
    use sparseir_rust::sve::compute_svd;
    
    let (sampling_u, sampling_s, sampling_v) = compute_svd(&sampling_matrices[0]);
    let (logistic_u, logistic_s, logistic_v) = compute_svd(&logistic_matrices[0]);
    let (centrosymm_even_u, centrosymm_even_s, centrosymm_even_v) = compute_svd(&centrosymm_matrices[0]);
    let (centrosymm_odd_u, centrosymm_odd_s, centrosymm_odd_v) = compute_svd(&centrosymm_matrices[1]);
    
    // Call postprocess with SVD results
    println!("Calling postproces...");
    println!("odd_s {:?}", centrosymm_odd_s);
    let centrosymm_result = centrosymm_sve.postprocess(
        vec![centrosymm_even_u, centrosymm_odd_u], 
        vec![centrosymm_even_s, centrosymm_odd_s], 
        vec![centrosymm_even_v, centrosymm_odd_v]
    );
    let sampling_result = sampling_sve.postprocess(
        vec![sampling_u], 
        vec![sampling_s], 
        vec![sampling_v]
    );
    let logistic_result = logistic_sampling_sve.postprocess(
        vec![logistic_u], 
        vec![logistic_s], 
        vec![logistic_v]
    );
    println!("Done postproces...");
    
    // Extract singular values and sort them
    let mut centrosymm_svals: Vec<f64> = centrosymm_result.s.iter().map(|&x| x).collect();
    let mut sampling_svals: Vec<f64> = sampling_result.s.iter().map(|&x| x).collect();
    let mut logistic_svals: Vec<f64> = logistic_result.s.iter().map(|&x| x).collect();
    
    centrosymm_svals.sort_by(|a, b| b.partial_cmp(a).unwrap());
    sampling_svals.sort_by(|a, b| b.partial_cmp(a).unwrap());
    logistic_svals.sort_by(|a, b| b.partial_cmp(a).unwrap());
    
    
    // For TestNonCentrosymmKernel, CentrosymmSVE should behave like SamplingSVE
    // since the kernel is not centrosymmetric
    assert_eq!(sampling_svals.len(), logistic_svals.len(),
               "SamplingSVE should have same number of singular values for same kernel");
    
    // Compare SamplingSVE results (should be identical for same kernel)
    let comparison_tolerance = 10.0 * epsilon;  // 10x tolerance for comparison
    for i in 0..std::cmp::min(logistic_svals.len(), sampling_svals.len()) {
        let diff_sampling_logistic = (sampling_svals[i] - logistic_svals[i]).abs();
        println!("{} {} {}", i, sampling_svals[i], logistic_svals[i]);
        
        assert!(diff_sampling_logistic < comparison_tolerance,
                "SamplingSVE singular values differ for same kernel by {} (tolerance: {})",
                diff_sampling_logistic, comparison_tolerance);
    }
    
    // CentrosymmSVE produces different results because it applies symmetry operations
    // even for non-centrosymmetric kernels. This is the current implementation behavior.
}

#[test]
fn test_centrosymm_sampling_singular_functions_match_positive_domain() {
    use sparseir_rust::kernel::{LogisticKernel, TestNonCentrosymmKernel};
    use sparseir_rust::sve::{SamplingSVE, CentrosymmSVE, compute_sve, TworkType};
    
    // Create test kernel that returns same values as LogisticKernel but is not centrosymmetric
    let lambda = 5.0;
    let test_kernel = TestNonCentrosymmKernel::new(lambda);
    let logistic_kernel = LogisticKernel::new(lambda);
    
    let epsilon = 1e-12;
    let n_gauss = Some(10);
    let cutoff = Some(1e-15);
    let max_num_svals = Some(1000);

    let test_sve_result = compute_sve(
        test_kernel, epsilon, cutoff, max_num_svals, n_gauss, TworkType::Float64
    );

    let sve_result = compute_sve(
        logistic_kernel, epsilon, cutoff, max_num_svals, n_gauss, TworkType::Float64
    );

    let min_nsvals = std::cmp::min(test_sve_result.s.len(), sve_result.s.len());
    for idx_sval in 0..min_nsvals {
        let diff = (test_sve_result.s[idx_sval] - sve_result.s[idx_sval]).abs();
        println!("{}, {}, {}, {}", idx_sval, test_sve_result.s[idx_sval], sve_result.s[idx_sval], diff);
        //assert!(diff/test_sve_result.s[0] < 10.0 * epsilon);
    }

    for x in [0.1, 0.2] {
        let test_uvals = test_sve_result.u.evaluate_at(x);
        let uvals = sve_result.u.evaluate_at(x);
        for i in 0..uvals.len() {
            assert!((test_uvals[i] - uvals[i]).abs() < 10.0 * epsilon);
        }
    }

    for y in [0.1, 0.2] {
        let test_vvals = test_sve_result.v.evaluate_at(y);
        let vvals = sve_result.v.evaluate_at(y);
        for i in 0..vvals.len() {
            assert!((test_vvals[i] - vvals[i]).abs() < 10.0 * epsilon);
        }
    }

    //assert!(
        //(sve_result.u.compute(x) - test_sve_result.u.compute(x)).abs() < 10 * eps, "u must match");
//
    
    /*
    // Create SVE hints for both kernels
    let test_hints = test_kernel.sve_hints::<f64>(epsilon);
    let logistic_hints = logistic_kernel.sve_hints::<f64>(epsilon);
    
    // Create CentrosymmSVE with test kernel
    let centrosymm_sve = CentrosymmSVE::new(test_kernel.clone(), test_hints.clone(), epsilon, n_gauss);
    
    // Create SamplingSVE with LogisticKernel (should be equivalent to CentrosymmSVE for centrosymmetric kernel)
    let sampling_sve = SamplingSVE::new(logistic_kernel.clone(), logistic_hints.clone(), epsilon, n_gauss);
    
    // Get matrices and compute SVD
    let centrosymm_matrices = centrosymm_sve.matrices();
    let sampling_matrices = sampling_sve.matrices();
    
    use sparseir_rust::sve::compute_svd;
    
    let (centrosymm_even_u, centrosymm_even_s, centrosymm_even_v) = compute_svd(&centrosymm_matrices[0]);
    let (centrosymm_odd_u, centrosymm_odd_s, centrosymm_odd_v) = compute_svd(&centrosymm_matrices[1]);
    let (sampling_u, sampling_s, sampling_v) = compute_svd(&sampling_matrices[0]);
    
    // Call postprocess to get singular functions
    let centrosymm_result = centrosymm_sve.postprocess(
        vec![centrosymm_even_u, centrosymm_odd_u], 
        vec![centrosymm_even_s, centrosymm_odd_s], 
        vec![centrosymm_even_v, centrosymm_odd_v]
    );
    let sampling_result = sampling_sve.postprocess(
        vec![sampling_u], 
        vec![sampling_s], 
        vec![sampling_v]
    );
    
    // Test singular functions at positive domain points (x > 0, y > 0)
    let test_x_points = vec![0.1, 0.3, 0.5, 0.7, 0.9, 0.15, 0.25, 0.35, 0.45, 0.55];
    let test_y_points = vec![0.2, 0.4, 0.6, 0.8, 0.1, 0.3, 0.5, 0.7, 0.9, 0.05];
    
    // Debug: print singular values and function counts
    println!("CentrosymmSVE has {} U functions, {} V functions", centrosymm_result.u.polyvec.len(), centrosymm_result.v.polyvec.len());
    println!("SamplingSVE has {} U functions, {} V functions", sampling_result.u.polyvec.len(), sampling_result.v.polyvec.len());
    println!("CentrosymmSVE singular values: {:?}", centrosymm_result.s.to_vec());
    println!("SamplingSVE singular values: {:?}", sampling_result.s.to_vec());
    
              // Print all U function values at x = 0.1 for debugging
              let x_test = 0.1;
              println!("\n=== U function values at x = {} ===", x_test);
              
              let n_functions_to_print = std::cmp::min(10, std::cmp::min(centrosymm_result.u.polyvec.len(), sampling_result.u.polyvec.len()));
              
              for func_idx in 0..n_functions_to_print {
                  let centrosymm_u = &centrosymm_result.u.polyvec[func_idx];
                  let sampling_u = &sampling_result.u.polyvec[func_idx];
                  
                  let centrosymm_u_val = centrosymm_u.evaluate(x_test);
                  let sampling_u_val = sampling_u.evaluate(x_test);
                  
                  println!("Function {}: CentrosymmSVE={:.15e}, SamplingSVE={:.15e}, diff={:.15e}", 
                           func_idx, centrosymm_u_val, sampling_u_val, (centrosymm_u_val - sampling_u_val).abs());
              }
              
              // Also print all CentrosymmSVE U values for comparison
              println!("\n=== All CentrosymmSVE U function values at x = {} ===", x_test);
              for func_idx in 0..centrosymm_result.u.polyvec.len() {
                  let centrosymm_u = &centrosymm_result.u.polyvec[func_idx];
                  let centrosymm_u_val = centrosymm_u.evaluate(x_test);
                  println!("CentrosymmSVE Function {}: {:.15e}", func_idx, centrosymm_u_val);
              }
              
              // Also print all SamplingSVE U values for comparison
              println!("\n=== All SamplingSVE U function values at x = {} ===", x_test);
              for func_idx in 0..sampling_result.u.polyvec.len() {
                  let sampling_u = &sampling_result.u.polyvec[func_idx];
                  let sampling_u_val = sampling_u.evaluate(x_test);
                  println!("SamplingSVE Function {}: {:.15e}", func_idx, sampling_u_val);
              }
              */
}

