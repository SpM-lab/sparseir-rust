/**
 * @file sparseir_capi.h
 * @brief C API for SparseIR library (Auto-generated by cbindgen)
 *
 * This header is automatically generated from Rust source code.
 * Do not modify this file manually - edit the Rust sources instead.
 */


#ifndef SPARSEIR_CAPI_H
#define SPARSEIR_CAPI_H

/* Generated with cbindgen:0.27.0 */

/* Warning: This file is autogenerated by cbindgen. Don't modify manually. */

#include <stdarg.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdlib.h>

typedef struct Arc_SVEResult Arc_SVEResult;

/**
 * Internal kernel type (not exposed to C)
 */
typedef struct KernelType KernelType;

/**
 * Error codes for C API (compatible with libsparseir)
 */
typedef int StatusCode;

/**
 * Opaque kernel type for C API (compatible with libsparseir)
 *
 * This is a tagged union that can hold either LogisticKernel or RegularizedBoseKernel.
 * The actual type is determined by which constructor was used.
 *
 * Note: Named `spir_kernel` to match libsparseir C++ API exactly.
 */
typedef struct spir_kernel {
    struct KernelType inner;
} spir_kernel;

/**
 * Opaque SVE result type for C API (compatible with libsparseir)
 *
 * Contains singular values and singular functions from SVE computation.
 *
 * Note: Named `spir_sve_result` to match libsparseir C++ API exactly.
 */
typedef struct spir_sve_result {
    struct Arc_SVEResult inner;
} spir_sve_result;

#define SPIR_COMPUTATION_SUCCESS 0

#define SPIR_GET_IMPL_FAILED -1

#define SPIR_INVALID_DIMENSION -2

#define SPIR_INPUT_DIMENSION_MISMATCH -3

#define SPIR_OUTPUT_DIMENSION_MISMATCH -4

#define SPIR_NOT_SUPPORTED -5

#define SPIR_INVALID_ARGUMENT -6

#define SPIR_INTERNAL_ERROR -7

#define SPIR_SUCCESS SPIR_COMPUTATION_SUCCESS

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

/**
 * Compute kernel value K(x, y)
 *
 * # Arguments
 * * `kernel` - Kernel object
 * * `x` - First argument (typically in [-1, 1])
 * * `y` - Second argument (typically in [-1, 1])
 * * `out` - Pointer to store the result
 *
 * # Returns
 * * `SPIR_SUCCESS` on success
 * * `SPIR_INVALID_ARGUMENT` if kernel or out is null
 * * `SPIR_INTERNAL_ERROR` if internal panic occurs
 */
StatusCode spir_kernel_compute(const struct spir_kernel *kernel, double x, double y, double *out);

/**
 * Get the lambda parameter of a kernel
 *
 * # Arguments
 * * `kernel` - Kernel object
 * * `lambda_out` - Pointer to store the lambda value
 *
 * # Returns
 * * `SPIR_SUCCESS` on success
 * * `SPIR_INVALID_ARGUMENT` if kernel or lambda_out is null
 * * `SPIR_INTERNAL_ERROR` if internal panic occurs
 */
StatusCode spir_kernel_lambda(const struct spir_kernel *kernel, double *lambda_out);

/**
 * Release a kernel object
 *
 * # Arguments
 * * `kernel` - Kernel to release (can be NULL)
 *
 * # Safety
 * After calling this function, the kernel pointer is invalid and must not be used.
 */
void spir_kernel_release(struct spir_kernel *kernel);

/**
 * Create a new Logistic kernel
 *
 * # Arguments
 * * `lambda` - The kernel parameter Λ = β * ωmax (must be > 0)
 * * `status` - Pointer to store the status code
 *
 * # Returns
 * * Pointer to the newly created kernel object, or NULL if creation fails
 *
 * # Safety
 * The caller must ensure `status` is a valid pointer.
 *
 * # Example (C)
 * ```c
 * int status;
 * spir_kernel* kernel = spir_logistic_kernel_new(10.0, &status);
 * if (kernel != NULL) {
 *     // Use kernel...
 *     spir_kernel_release(kernel);
 * }
 * ```
 */
struct spir_kernel *spir_logistic_kernel_new(double lambda, StatusCode *status);

/**
 * Create a new RegularizedBose kernel
 *
 * # Arguments
 * * `lambda` - The kernel parameter Λ = β * ωmax (must be > 0)
 * * `status` - Pointer to store the status code
 *
 * # Returns
 * * Pointer to the newly created kernel object, or NULL if creation fails
 */
struct spir_kernel *spir_reg_bose_kernel_new(double lambda, StatusCode *status);

/**
 * Get the number of singular values in an SVE result
 *
 * # Arguments
 * * `sve` - SVE result object
 * * `size` - Pointer to store the size
 *
 * # Returns
 * * `SPIR_SUCCESS` (0) on success
 * * `SPIR_INVALID_ARGUMENT` (-6) if sve or size is null
 * * `SPIR_INTERNAL_ERROR` (-7) if internal panic occurs
 */
StatusCode spir_sve_result_get_size(const struct spir_sve_result *sve, int *size);

/**
 * Get singular values from an SVE result
 *
 * # Arguments
 * * `sve` - SVE result object
 * * `svals` - Pre-allocated array to store singular values (size must be >= result size)
 *
 * # Returns
 * * `SPIR_SUCCESS` (0) on success
 * * `SPIR_INVALID_ARGUMENT` (-6) if sve or svals is null
 * * `SPIR_INTERNAL_ERROR` (-7) if internal panic occurs
 */
StatusCode spir_sve_result_get_svals(const struct spir_sve_result *sve, double *svals);

/**
 * Compute Singular Value Expansion (SVE) of a kernel (libsparseir compatible)
 *
 * # Arguments
 * * `k` - Kernel object
 * * `epsilon` - Accuracy target for the basis
 * * `cutoff` - Cutoff value for singular values (-1 for default: 2*sqrt(machine_epsilon))
 * * `lmax` - Maximum number of Legendre polynomials (currently ignored, auto-determined)
 * * `n_gauss` - Number of Gauss points for integration (currently ignored, auto-determined)
 * * `Twork` - Working precision: 0=Float64, 1=Float64x2, -1=Auto
 * * `status` - Pointer to store status code
 *
 * # Returns
 * * Pointer to SVE result, or NULL on failure
 *
 * # Safety
 * The caller must ensure `status` is a valid pointer.
 *
 * # Note
 * Parameters `lmax` and `n_gauss` are accepted for libsparseir compatibility but
 * currently ignored. The Rust implementation automatically determines optimal values.
 */
struct spir_sve_result *spir_sve_result_new(const struct spir_kernel *k,
                                            double epsilon,
                                            double cutoff,
                                            int _lmax,
                                            int _n_gauss,
                                            int twork,
                                            StatusCode *status);

/**
 * Release an SVE result object
 *
 * # Arguments
 * * `sve` - SVE result to release (can be NULL)
 *
 * # Safety
 * After calling this function, the sve pointer is invalid and must not be used.
 */
void spir_sve_result_release(struct spir_sve_result *sve);

/**
 * Truncate an SVE result
 *
 * # Arguments
 * * `sve` - SVE result object
 * * `epsilon` - New accuracy target
 * * `max_size` - Maximum number of singular values to keep (-1 for no limit)
 * * `status` - Pointer to store status code
 *
 * # Returns
 * * Pointer to new truncated SVE result, or NULL on failure
 *
 * # Safety
 * The caller must ensure `status` is a valid pointer.
 */
struct spir_sve_result *spir_sve_result_truncate(const struct spir_sve_result *sve,
                                                 double epsilon,
                                                 int max_size,
                                                 StatusCode *status);

#ifdef __cplusplus
}  // extern "C"
#endif  // __cplusplus

#endif  /* SPARSEIR_CAPI_H */
