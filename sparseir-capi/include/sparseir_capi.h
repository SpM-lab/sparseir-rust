/**
 * @file sparseir_capi.h
 * @brief C API for SparseIR library (Auto-generated by cbindgen)
 *
 * This header is automatically generated from Rust source code.
 * Do not modify this file manually - edit the Rust sources instead.
 */


#ifndef SPARSEIR_CAPI_H
#define SPARSEIR_CAPI_H

/* Generated with cbindgen:0.27.0 */

/* Warning: This file is autogenerated by cbindgen. Don't modify manually. */

#include <stdarg.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdlib.h>

#define SPIR_ORDER_ROW_MAJOR 0

#define SPIR_ORDER_COLUMN_MAJOR 1

#define SPIR_STATISTICS_BOSONIC 0

#define SPIR_STATISTICS_FERMIONIC 1

typedef struct Arc_SVEResult Arc_SVEResult;

/**
 * Internal basis type (not exposed to C)
 */
typedef struct BasisType BasisType;

/**
 * Internal enum to hold different function types
 */
typedef struct FuncsType FuncsType;

/**
 * Internal kernel type (not exposed to C)
 */
typedef struct KernelType KernelType;

/**
 * Internal enum to distinguish between different sampling types
 */
typedef struct SamplingType SamplingType;

/**
 * Error codes for C API (compatible with libsparseir)
 */
typedef int StatusCode;

/**
 * Opaque basis type for C API (compatible with libsparseir)
 *
 * Represents a finite temperature basis (IR or DLR).
 *
 * Note: Named `spir_basis` to match libsparseir C++ API exactly.
 */
typedef struct spir_basis {
    struct BasisType inner;
} spir_basis;

/**
 * Opaque funcs type for C API (compatible with libsparseir)
 *
 * Wraps piecewise Legendre polynomial representations:
 * - PiecewiseLegendrePolyVector for u and v
 * - PiecewiseLegendreFTVector for uhat
 *
 * Note: Named `spir_funcs` to match libsparseir C++ API exactly.
 */
typedef struct spir_funcs {
    struct FuncsType inner;
    double beta;
} spir_funcs;

/**
 * Opaque kernel type for C API (compatible with libsparseir)
 *
 * This is a tagged union that can hold either LogisticKernel or RegularizedBoseKernel.
 * The actual type is determined by which constructor was used.
 *
 * Note: Named `spir_kernel` to match libsparseir C++ API exactly.
 */
typedef struct spir_kernel {
    struct KernelType inner;
} spir_kernel;

/**
 * Opaque SVE result type for C API (compatible with libsparseir)
 *
 * Contains singular values and singular functions from SVE computation.
 *
 * Note: Named `spir_sve_result` to match libsparseir C++ API exactly.
 */
typedef struct spir_sve_result {
    struct Arc_SVEResult inner;
} spir_sve_result;

/**
 * Sampling type for C API (unified type for all domains)
 *
 * This wraps different sampling implementations:
 * - TauSampling (for tau-domain)
 * - MatsubaraSampling (for Matsubara frequencies, full range or positive-only)
 */
typedef struct spir_sampling {
    struct SamplingType inner;
} spir_sampling;

#define SPIR_COMPUTATION_SUCCESS 0

#define SPIR_GET_IMPL_FAILED -1

#define SPIR_INVALID_DIMENSION -2

#define SPIR_INPUT_DIMENSION_MISMATCH -3

#define SPIR_OUTPUT_DIMENSION_MISMATCH -4

#define SPIR_NOT_SUPPORTED -5

#define SPIR_INVALID_ARGUMENT -6

#define SPIR_INTERNAL_ERROR -7

#define SPIR_SUCCESS SPIR_COMPUTATION_SUCCESS

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

/**
 * Get default Matsubara sampling points
 *
 * # Arguments
 * * `b` - Basis object
 * * `positive_only` - If true, return only positive frequencies
 * * `points` - Pre-allocated array to store Matsubara indices
 *
 * # Returns
 * * `SPIR_SUCCESS` (0) on success
 * * `SPIR_INVALID_ARGUMENT` (-6) if b or points is null
 * * `SPIR_INTERNAL_ERROR` (-7) if internal panic occurs
 */
StatusCode spir_basis_get_default_matsus(const struct spir_basis *b,
                                         bool positive_only,
                                         int64_t *points);

/**
 * Get default Matsubara sampling points with custom limit (extended version)
 *
 * # Arguments
 * * `b` - Basis object
 * * `positive_only` - If true, return only positive frequencies
 * * `n_points` - Maximum number of points requested
 * * `points` - Pre-allocated array to store Matsubara indices (size >= n_points)
 * * `n_points_returned` - Pointer to store actual number of points returned
 *
 * # Returns
 * * `SPIR_SUCCESS` (0) on success
 * * `SPIR_INVALID_ARGUMENT` (-6) if any pointer is null or n_points < 0
 * * `SPIR_INTERNAL_ERROR` (-7) if internal panic occurs
 *
 * # Note
 * Returns min(n_points, actual_default_points) sampling points
 */
StatusCode spir_basis_get_default_matsus_ext(const struct spir_basis *b,
                                             bool positive_only,
                                             int n_points,
                                             int64_t *points,
                                             int *n_points_returned);

/**
 * Get default tau sampling points
 *
 * # Arguments
 * * `b` - Basis object
 * * `points` - Pre-allocated array to store tau points
 *
 * # Returns
 * * `SPIR_SUCCESS` (0) on success
 * * `SPIR_INVALID_ARGUMENT` (-6) if b or points is null
 * * `SPIR_INTERNAL_ERROR` (-7) if internal panic occurs
 */
StatusCode spir_basis_get_default_taus(const struct spir_basis *b, double *points);

/**
 * Get default tau sampling points with custom limit (extended version)
 *
 * # Arguments
 * * `b` - Basis object
 * * `n_points` - Maximum number of points requested
 * * `points` - Pre-allocated array to store tau points (size >= n_points)
 * * `n_points_returned` - Pointer to store actual number of points returned
 *
 * # Returns
 * * `SPIR_SUCCESS` (0) on success
 * * `SPIR_INVALID_ARGUMENT` (-6) if any pointer is null or n_points < 0
 * * `SPIR_INTERNAL_ERROR` (-7) if internal panic occurs
 *
 * # Note
 * Returns min(n_points, actual_default_points) sampling points
 */
StatusCode spir_basis_get_default_taus_ext(const struct spir_basis *b,
                                           int n_points,
                                           double *points,
                                           int *n_points_returned);

/**
 * Gets the default omega (real frequency) sampling points
 *
 * # Arguments
 * * `b` - Pointer to the finite temperature basis object
 * * `points` - Pre-allocated array to store the omega sampling points
 *
 * # Returns
 * Status code (SPIR_SUCCESS on success)
 *
 * # Safety
 * The caller must ensure that `points` has size >= `spir_basis_get_n_default_ws(b)`
 */
StatusCode spir_basis_get_default_ws(const struct spir_basis *b, double *points);

/**
 * Get the number of default Matsubara sampling points
 *
 * # Arguments
 * * `b` - Basis object
 * * `positive_only` - If true, return only positive frequencies
 * * `num_points` - Pointer to store the number of points
 *
 * # Returns
 * * `SPIR_SUCCESS` (0) on success
 * * `SPIR_INVALID_ARGUMENT` (-6) if b or num_points is null
 * * `SPIR_INTERNAL_ERROR` (-7) if internal panic occurs
 */
StatusCode spir_basis_get_n_default_matsus(const struct spir_basis *b,
                                           bool positive_only,
                                           int *num_points);

/**
 * Get number of default Matsubara sampling points with custom limit (extended version)
 *
 * # Arguments
 * * `b` - Basis object
 * * `positive_only` - If true, return only positive frequencies
 * * `L` - Requested number of sampling points
 * * `num_points_returned` - Pointer to store actual number of points
 *
 * # Returns
 * * `SPIR_SUCCESS` (0) on success
 * * `SPIR_INVALID_ARGUMENT` (-6) if any pointer is null or L < 0
 * * `SPIR_INTERNAL_ERROR` (-7) if internal panic occurs
 *
 * # Note
 * Returns min(L, actual_default_points) sampling points
 */
StatusCode spir_basis_get_n_default_matsus_ext(const struct spir_basis *b,
                                               bool positive_only,
                                               int L,
                                               int *num_points_returned);

/**
 * Get the number of default tau sampling points
 *
 * # Arguments
 * * `b` - Basis object
 * * `num_points` - Pointer to store the number of points
 *
 * # Returns
 * * `SPIR_SUCCESS` (0) on success
 * * `SPIR_INVALID_ARGUMENT` (-6) if b or num_points is null
 * * `SPIR_INTERNAL_ERROR` (-7) if internal panic occurs
 */
StatusCode spir_basis_get_n_default_taus(const struct spir_basis *b, int *num_points);

/**
 * Gets the number of default omega (real frequency) sampling points
 *
 * # Arguments
 * * `b` - Pointer to the finite temperature basis object
 * * `num_points` - Pointer to store the number of sampling points
 *
 * # Returns
 * Status code (SPIR_SUCCESS on success)
 *
 * # Safety
 * The caller must ensure that `b` and `num_points` are valid pointers
 */
StatusCode spir_basis_get_n_default_ws(const struct spir_basis *b, int *num_points);

/**
 * Get singular values (alias for spir_basis_get_svals for libsparseir compatibility)
 */
StatusCode spir_basis_get_singular_values(const struct spir_basis *b, double *svals);

/**
 * Get the number of basis functions
 *
 * # Arguments
 * * `b` - Basis object
 * * `size` - Pointer to store the size
 *
 * # Returns
 * * `SPIR_SUCCESS` (0) on success
 * * `SPIR_INVALID_ARGUMENT` (-6) if b or size is null
 * * `SPIR_INTERNAL_ERROR` (-7) if internal panic occurs
 */
StatusCode spir_basis_get_size(const struct spir_basis *b, int *size);

/**
 * Get statistics type (Fermionic or Bosonic) of a basis
 *
 * # Arguments
 * * `b` - Basis object
 * * `statistics` - Pointer to store statistics (0 = Bosonic, 1 = Fermionic)
 *
 * # Returns
 * * `SPIR_SUCCESS` (0) on success
 * * `SPIR_INVALID_ARGUMENT` (-6) if b or statistics is null
 * * `SPIR_INTERNAL_ERROR` (-7) if internal panic occurs
 */
StatusCode spir_basis_get_stats(const struct spir_basis *b, int *statistics);

/**
 * Get singular values from a basis
 *
 * # Arguments
 * * `b` - Basis object
 * * `svals` - Pre-allocated array to store singular values (size must be >= basis size)
 *
 * # Returns
 * * `SPIR_SUCCESS` (0) on success
 * * `SPIR_INVALID_ARGUMENT` (-6) if b or svals is null
 * * `SPIR_INTERNAL_ERROR` (-7) if internal panic occurs
 */
StatusCode spir_basis_get_svals(const struct spir_basis *b, double *svals);

/**
 * Gets the basis functions in imaginary time (τ) domain
 *
 * # Arguments
 * * `b` - Pointer to the finite temperature basis object
 * * `status` - Pointer to store the status code
 *
 * # Returns
 * Pointer to the basis functions object (`spir_funcs`), or NULL if creation fails
 *
 * # Safety
 * The caller must ensure that `b` is a valid pointer, and must call
 * `spir_funcs_release()` on the returned pointer when done.
 */
struct spir_funcs *spir_basis_get_u(const struct spir_basis *b, StatusCode *status);

/**
 * Gets the basis functions in Matsubara frequency domain
 *
 * # Arguments
 * * `b` - Pointer to the finite temperature basis object
 * * `status` - Pointer to store the status code
 *
 * # Returns
 * Pointer to the basis functions object (`spir_funcs`), or NULL if creation fails
 *
 * # Safety
 * The caller must ensure that `b` is a valid pointer, and must call
 * `spir_funcs_release()` on the returned pointer when done.
 */
struct spir_funcs *spir_basis_get_uhat(const struct spir_basis *b, StatusCode *status);

/**
 * Gets the basis functions in real frequency (ω) domain
 *
 * # Arguments
 * * `b` - Pointer to the finite temperature basis object
 * * `status` - Pointer to store the status code
 *
 * # Returns
 * Pointer to the basis functions object (`spir_funcs`), or NULL if creation fails
 *
 * # Safety
 * The caller must ensure that `b` is a valid pointer, and must call
 * `spir_funcs_release()` on the returned pointer when done.
 */
struct spir_funcs *spir_basis_get_v(const struct spir_basis *b, StatusCode *status);

/**
 * Create a finite temperature basis (libsparseir compatible)
 *
 * # Arguments
 * * `statistics` - 0 for Bosonic, 1 for Fermionic
 * * `beta` - Inverse temperature (must be > 0)
 * * `omega_max` - Frequency cutoff (must be > 0)
 * * `epsilon` - Accuracy target (must be > 0)
 * * `k` - Kernel object (can be NULL if sve is provided)
 * * `sve` - Pre-computed SVE result (can be NULL, will compute if needed)
 * * `max_size` - Maximum basis size (-1 for no limit)
 * * `status` - Pointer to store status code
 *
 * # Returns
 * * Pointer to basis object, or NULL on failure
 *
 * # Safety
 * The caller must ensure `status` is a valid pointer.
 */
struct spir_basis *spir_basis_new(int statistics,
                                  double beta,
                                  double omega_max,
                                  double epsilon,
                                  const struct spir_kernel *k,
                                  const struct spir_sve_result *sve,
                                  int max_size,
                                  StatusCode *status);

/**
 * Convert DLR coefficients to IR (real-valued)
 *
 * # Arguments
 * * `dlr` - Pointer to a DLR basis object
 * * `order` - Memory layout order
 * * `ndim` - Number of dimensions
 * * `input_dims` - Array of input dimensions
 * * `target_dim` - Dimension to transform
 * * `input` - DLR coefficients
 * * `out` - Output IR coefficients
 *
 * # Returns
 * Status code
 *
 * # Safety
 * Caller must ensure pointers are valid and arrays have correct sizes
 */
StatusCode spir_dlr2ir_dd(const struct spir_basis *dlr,
                          int order,
                          int ndim,
                          const int *input_dims,
                          int target_dim,
                          const double *input,
                          double *out);

/**
 * Convert DLR coefficients to IR (complex-valued)
 *
 * # Arguments
 * * `dlr` - Pointer to a DLR basis object
 * * `order` - Memory layout order
 * * `ndim` - Number of dimensions
 * * `input_dims` - Array of input dimensions
 * * `target_dim` - Dimension to transform
 * * `input` - Complex DLR coefficients
 * * `out` - Output complex IR coefficients
 *
 * # Returns
 * Status code
 *
 * # Safety
 * Caller must ensure pointers are valid and arrays have correct sizes
 */
StatusCode spir_dlr2ir_zz(const struct spir_basis *dlr,
                          int order,
                          int ndim,
                          const int *input_dims,
                          int target_dim,
                          const Complex64 *input,
                          Complex64 *out);

/**
 * Gets the number of poles in a DLR
 *
 * # Arguments
 * * `dlr` - Pointer to a DLR basis object
 * * `num_poles` - Pointer to store the number of poles
 *
 * # Returns
 * Status code
 *
 * # Safety
 * Caller must ensure `dlr` is a valid DLR basis pointer
 */
StatusCode spir_dlr_get_npoles(const struct spir_basis *dlr, int *num_poles);

/**
 * Gets the pole locations in a DLR
 *
 * # Arguments
 * * `dlr` - Pointer to a DLR basis object
 * * `poles` - Pre-allocated array to store pole locations
 *
 * # Returns
 * Status code
 *
 * # Safety
 * Caller must ensure `dlr` is valid and `poles` has sufficient size
 */
StatusCode spir_dlr_get_poles(const struct spir_basis *dlr, double *poles);

/**
 * Creates a new DLR from an IR basis with default poles
 *
 * # Arguments
 * * `b` - Pointer to a finite temperature basis object
 * * `status` - Pointer to store the status code
 *
 * # Returns
 * Pointer to the newly created DLR basis object, or NULL if creation fails
 *
 * # Safety
 * Caller must ensure `b` is a valid IR basis pointer
 */
struct spir_basis *spir_dlr_new(const struct spir_basis *b, StatusCode *status);

/**
 * Creates a new DLR with custom poles
 *
 * # Arguments
 * * `b` - Pointer to a finite temperature basis object
 * * `npoles` - Number of poles to use
 * * `poles` - Array of pole locations on the real-frequency axis
 * * `status` - Pointer to store the status code
 *
 * # Returns
 * Pointer to the newly created DLR basis object, or NULL if creation fails
 *
 * # Safety
 * Caller must ensure `b` is valid and `poles` has `npoles` elements
 */
struct spir_basis *spir_dlr_new_with_poles(const struct spir_basis *b,
                                           int npoles,
                                           const double *poles,
                                           StatusCode *status);

/**
 * Batch evaluate functions at multiple points (continuous functions only)
 *
 * # Arguments
 * * `funcs` - Pointer to the funcs object
 * * `order` - Memory layout: 0 for row-major, 1 for column-major
 * * `num_points` - Number of evaluation points
 * * `xs` - Array of points to evaluate at
 * * `out` - Pre-allocated array to store results
 *
 * # Returns
 * Status code (SPIR_SUCCESS on success, SPIR_NOT_SUPPORTED if not continuous)
 *
 * # Safety
 * - `xs` must have size >= `num_points`
 * - `out` must have size >= `num_points * spir_funcs_get_size(funcs)`
 * - Layout: row-major = out[point][func], column-major = out[func][point]
 */
StatusCode spir_funcs_batch_eval(const struct spir_funcs *funcs,
                                 int order,
                                 int num_points,
                                 const double *xs,
                                 double *out);

/**
 * Batch evaluate functions at multiple Matsubara frequencies
 *
 * # Arguments
 * * `funcs` - Pointer to the funcs object
 * * `order` - Memory layout: 0 for row-major, 1 for column-major
 * * `num_freqs` - Number of Matsubara frequencies
 * * `ns` - Array of Matsubara frequency indices
 * * `out` - Pre-allocated array to store complex results
 *
 * # Returns
 * Status code (SPIR_SUCCESS on success, SPIR_NOT_SUPPORTED if not Matsubara type)
 *
 * # Safety
 * - `ns` must have size >= `num_freqs`
 * - `out` must have size >= `num_freqs * spir_funcs_get_size(funcs)`
 * - Complex numbers are laid out as [real, imag] pairs
 * - Layout: row-major = out[freq][func], column-major = out[func][freq]
 */
StatusCode spir_funcs_batch_eval_matsu(const struct spir_funcs *funcs,
                                       int order,
                                       int num_freqs,
                                       const int64_t *ns,
                                       Complex64 *out);

/**
 * Evaluate functions at a single point (continuous functions only)
 *
 * # Arguments
 * * `funcs` - Pointer to the funcs object
 * * `x` - Point to evaluate at (tau coordinate in [-1, 1])
 * * `out` - Pre-allocated array to store function values
 *
 * # Returns
 * Status code (SPIR_SUCCESS on success, SPIR_NOT_SUPPORTED if not continuous)
 *
 * # Safety
 * The caller must ensure that `out` has size >= `spir_funcs_get_size(funcs)`
 */
StatusCode spir_funcs_eval(const struct spir_funcs *funcs, double x, double *out);

/**
 * Evaluate functions at a single Matsubara frequency
 *
 * # Arguments
 * * `funcs` - Pointer to the funcs object
 * * `n` - Matsubara frequency index
 * * `out` - Pre-allocated array to store complex function values
 *
 * # Returns
 * Status code (SPIR_SUCCESS on success, SPIR_NOT_SUPPORTED if not Matsubara type)
 *
 * # Safety
 * The caller must ensure that `out` has size >= `spir_funcs_get_size(funcs)`
 * Complex numbers are laid out as [real, imag] pairs
 */
StatusCode spir_funcs_eval_matsu(const struct spir_funcs *funcs, int64_t n, Complex64 *out);

/**
 * Gets the knot positions for continuous functions
 *
 * # Arguments
 * * `funcs` - Pointer to the funcs object
 * * `knots` - Pre-allocated array to store knot positions
 *
 * # Returns
 * Status code (SPIR_SUCCESS on success, SPIR_NOT_SUPPORTED if not continuous)
 *
 * # Safety
 * The caller must ensure that `knots` has size >= `spir_funcs_get_n_knots(funcs)`
 */
StatusCode spir_funcs_get_knots(const struct spir_funcs *funcs, double *knots);

/**
 * Gets the number of knots for continuous functions
 *
 * # Arguments
 * * `funcs` - Pointer to the funcs object
 * * `n_knots` - Pointer to store the number of knots
 *
 * # Returns
 * Status code (SPIR_SUCCESS on success, SPIR_NOT_SUPPORTED if not continuous)
 */
StatusCode spir_funcs_get_n_knots(const struct spir_funcs *funcs, int *n_knots);

/**
 * Gets the number of basis functions
 *
 * # Arguments
 * * `funcs` - Pointer to the funcs object
 * * `size` - Pointer to store the number of functions
 *
 * # Returns
 * Status code (SPIR_SUCCESS on success)
 */
StatusCode spir_funcs_get_size(const struct spir_funcs *funcs, int *size);

/**
 * Extract a subset of functions by indices
 *
 * # Arguments
 * * `funcs` - Pointer to the source funcs object
 * * `nslice` - Number of functions to select (length of indices array)
 * * `indices` - Array of indices specifying which functions to include
 * * `status` - Pointer to store the status code
 *
 * # Returns
 * Pointer to a new funcs object containing only the selected functions, or null on error
 *
 * # Safety
 * The caller must ensure that `funcs` and `indices` are valid pointers.
 * The returned pointer must be freed with `spir_funcs_release()`.
 */
struct spir_funcs *spir_funcs_get_slice(const struct spir_funcs *funcs,
                                        int32_t nslice,
                                        const int32_t *indices,
                                        StatusCode *status);

/**
 * Convert IR coefficients to DLR (real-valued)
 *
 * # Arguments
 * * `dlr` - Pointer to a DLR basis object
 * * `order` - Memory layout order
 * * `ndim` - Number of dimensions
 * * `input_dims` - Array of input dimensions
 * * `target_dim` - Dimension to transform
 * * `input` - IR coefficients
 * * `out` - Output DLR coefficients
 *
 * # Returns
 * Status code
 *
 * # Safety
 * Caller must ensure pointers are valid and arrays have correct sizes
 */
StatusCode spir_ir2dlr_dd(const struct spir_basis *dlr,
                          int order,
                          int ndim,
                          const int *input_dims,
                          int target_dim,
                          const double *input,
                          double *out);

/**
 * Convert IR coefficients to DLR (complex-valued)
 *
 * # Arguments
 * * `dlr` - Pointer to a DLR basis object
 * * `order` - Memory layout order
 * * `ndim` - Number of dimensions
 * * `input_dims` - Array of input dimensions
 * * `target_dim` - Dimension to transform
 * * `input` - Complex IR coefficients
 * * `out` - Output complex DLR coefficients
 *
 * # Returns
 * Status code
 *
 * # Safety
 * Caller must ensure pointers are valid and arrays have correct sizes
 */
StatusCode spir_ir2dlr_zz(const struct spir_basis *dlr,
                          int order,
                          int ndim,
                          const int *input_dims,
                          int target_dim,
                          const Complex64 *input,
                          Complex64 *out);

/**
 * Compute kernel value K(x, y)
 *
 * # Arguments
 * * `kernel` - Kernel object
 * * `x` - First argument (typically in [-1, 1])
 * * `y` - Second argument (typically in [-1, 1])
 * * `out` - Pointer to store the result
 *
 * # Returns
 * * `SPIR_SUCCESS` on success
 * * `SPIR_INVALID_ARGUMENT` if kernel or out is null
 * * `SPIR_INTERNAL_ERROR` if internal panic occurs
 */
StatusCode spir_kernel_compute(const struct spir_kernel *kernel, double x, double y, double *out);

/**
 * Get the lambda parameter of a kernel
 *
 * # Arguments
 * * `kernel` - Kernel object
 * * `lambda_out` - Pointer to store the lambda value
 *
 * # Returns
 * * `SPIR_SUCCESS` on success
 * * `SPIR_INVALID_ARGUMENT` if kernel or lambda_out is null
 * * `SPIR_INTERNAL_ERROR` if internal panic occurs
 */
StatusCode spir_kernel_lambda(const struct spir_kernel *kernel, double *lambda_out);

/**
 * Create a new Logistic kernel
 *
 * # Arguments
 * * `lambda` - The kernel parameter Λ = β * ωmax (must be > 0)
 * * `status` - Pointer to store the status code
 *
 * # Returns
 * * Pointer to the newly created kernel object, or NULL if creation fails
 *
 * # Safety
 * The caller must ensure `status` is a valid pointer.
 *
 * # Example (C)
 * ```c
 * int status;
 * spir_kernel* kernel = spir_logistic_kernel_new(10.0, &status);
 * if (kernel != NULL) {
 *     // Use kernel...
 *     spir_kernel_release(kernel);
 * }
 * ```
 */
struct spir_kernel *spir_logistic_kernel_new(double lambda, StatusCode *status);

/**
 * Creates a new Matsubara sampling object for sparse sampling in Matsubara frequencies
 *
 * # Arguments
 * * `b` - Pointer to a finite temperature basis object
 * * `positive_only` - If true, only positive frequencies are used
 * * `num_points` - Number of sampling points
 * * `points` - Array of Matsubara frequency indices (n)
 * * `status` - Pointer to store the status code
 *
 * # Returns
 * Pointer to the newly created sampling object, or NULL if creation fails
 */
struct spir_sampling *spir_matsu_sampling_new(const struct spir_basis *b,
                                              bool positive_only,
                                              int num_points,
                                              const int64_t *points,
                                              StatusCode *status);

/**
 * Creates a new Matsubara sampling object with custom sampling points and pre-computed matrix
 *
 * # Arguments
 * * `order` - Memory layout order (SPIR_ORDER_ROW_MAJOR or SPIR_ORDER_COLUMN_MAJOR)
 * * `statistics` - Statistics type (SPIR_STATISTICS_FERMIONIC or SPIR_STATISTICS_BOSONIC)
 * * `basis_size` - Basis size
 * * `positive_only` - If true, only positive frequencies are used
 * * `num_points` - Number of sampling points
 * * `points` - Array of Matsubara frequency indices (n)
 * * `matrix` - Pre-computed complex matrix (num_points x basis_size)
 * * `status` - Pointer to store the status code
 *
 * # Returns
 * Pointer to the newly created sampling object, or NULL if creation fails
 *
 * # Safety
 * Caller must ensure `points` and `matrix` have correct sizes
 */
struct spir_sampling *spir_matsu_sampling_new_with_matrix(int order,
                                                          int statistics,
                                                          int basis_size,
                                                          bool positive_only,
                                                          int num_points,
                                                          const int64_t *points,
                                                          const Complex64 *matrix,
                                                          StatusCode *status);

/**
 * Create a new RegularizedBose kernel
 *
 * # Arguments
 * * `lambda` - The kernel parameter Λ = β * ωmax (must be > 0)
 * * `status` - Pointer to store the status code
 *
 * # Returns
 * * Pointer to the newly created kernel object, or NULL if creation fails
 */
struct spir_kernel *spir_reg_bose_kernel_new(double lambda, StatusCode *status);

/**
 * Evaluate basis coefficients at sampling points (double → double)
 *
 * Transforms IR basis coefficients to values at sampling points.
 *
 * # Note
 * Currently only supports column-major order (SPIR_ORDER_COLUMN_MAJOR = 1).
 * Row-major support will be added in a future update.
 */
StatusCode spir_sampling_eval_dd(const struct spir_sampling *s,
                                 int order,
                                 int ndim,
                                 const int *input_dims,
                                 int target_dim,
                                 const double *input,
                                 double *out);

/**
 * Evaluate basis coefficients at sampling points (double → complex)
 *
 * For Matsubara sampling: transforms real IR coefficients to complex values.
 */
StatusCode spir_sampling_eval_dz(const struct spir_sampling *s,
                                 int order,
                                 int ndim,
                                 const int *input_dims,
                                 int target_dim,
                                 const double *input,
                                 Complex64 *out);

/**
 * Evaluate basis coefficients at sampling points (complex → complex)
 *
 * For Matsubara sampling: transforms complex coefficients to complex values.
 */
StatusCode spir_sampling_eval_zz(const struct spir_sampling *s,
                                 int order,
                                 int ndim,
                                 const int *input_dims,
                                 int target_dim,
                                 const Complex64 *input,
                                 Complex64 *out);

/**
 * Fit basis coefficients from sampling point values (double → double)
 */
StatusCode spir_sampling_fit_dd(const struct spir_sampling *s,
                                int order,
                                int ndim,
                                const int *input_dims,
                                int target_dim,
                                const double *input,
                                double *out);

/**
 * Fit basis coefficients from Matsubara sampling (complex → double, positive only)
 */
StatusCode spir_sampling_fit_zd(const struct spir_sampling *s,
                                int order,
                                int ndim,
                                const int *input_dims,
                                int target_dim,
                                const Complex64 *input,
                                double *out);

/**
 * Fit basis coefficients from sampling point values (complex → complex)
 */
StatusCode spir_sampling_fit_zz(const struct spir_sampling *s,
                                int order,
                                int ndim,
                                const int *input_dims,
                                int target_dim,
                                const Complex64 *input,
                                Complex64 *out);

/**
 * Gets the condition number of the sampling matrix
 *
 * Note: Currently returns a placeholder value.
 * TODO: Implement proper condition number calculation from SVD
 */
StatusCode spir_sampling_get_cond_num(const struct spir_sampling *s, double *cond_num);

/**
 * Gets the Matsubara frequency sampling points
 */
StatusCode spir_sampling_get_matsus(const struct spir_sampling *s, int64_t *points);

/**
 * Gets the number of sampling points in a sampling object
 */
StatusCode spir_sampling_get_npoints(const struct spir_sampling *s, int *num_points);

/**
 * Gets the imaginary time sampling points
 */
StatusCode spir_sampling_get_taus(const struct spir_sampling *s, double *points);

/**
 * Get the number of singular values in an SVE result
 *
 * # Arguments
 * * `sve` - SVE result object
 * * `size` - Pointer to store the size
 *
 * # Returns
 * * `SPIR_SUCCESS` (0) on success
 * * `SPIR_INVALID_ARGUMENT` (-6) if sve or size is null
 * * `SPIR_INTERNAL_ERROR` (-7) if internal panic occurs
 */
StatusCode spir_sve_result_get_size(const struct spir_sve_result *sve, int *size);

/**
 * Get singular values from an SVE result
 *
 * # Arguments
 * * `sve` - SVE result object
 * * `svals` - Pre-allocated array to store singular values (size must be >= result size)
 *
 * # Returns
 * * `SPIR_SUCCESS` (0) on success
 * * `SPIR_INVALID_ARGUMENT` (-6) if sve or svals is null
 * * `SPIR_INTERNAL_ERROR` (-7) if internal panic occurs
 */
StatusCode spir_sve_result_get_svals(const struct spir_sve_result *sve, double *svals);

/**
 * Compute Singular Value Expansion (SVE) of a kernel (libsparseir compatible)
 *
 * # Arguments
 * * `k` - Kernel object
 * * `epsilon` - Accuracy target for the basis
 * * `cutoff` - Cutoff value for singular values (-1 for default: 2*sqrt(machine_epsilon))
 * * `lmax` - Maximum number of Legendre polynomials (currently ignored, auto-determined)
 * * `n_gauss` - Number of Gauss points for integration (currently ignored, auto-determined)
 * * `Twork` - Working precision: 0=Float64, 1=Float64x2, -1=Auto
 * * `status` - Pointer to store status code
 *
 * # Returns
 * * Pointer to SVE result, or NULL on failure
 *
 * # Safety
 * The caller must ensure `status` is a valid pointer.
 *
 * # Note
 * Parameters `lmax` and `n_gauss` are accepted for libsparseir compatibility but
 * currently ignored. The Rust implementation automatically determines optimal values.
 */
struct spir_sve_result *spir_sve_result_new(const struct spir_kernel *k,
                                            double epsilon,
                                            double cutoff,
                                            int _lmax,
                                            int _n_gauss,
                                            int twork,
                                            StatusCode *status);

/**
 * Truncate an SVE result
 *
 * # Arguments
 * * `sve` - SVE result object
 * * `epsilon` - New accuracy target
 * * `max_size` - Maximum number of singular values to keep (-1 for no limit)
 * * `status` - Pointer to store status code
 *
 * # Returns
 * * Pointer to new truncated SVE result, or NULL on failure
 *
 * # Safety
 * The caller must ensure `status` is a valid pointer.
 */
struct spir_sve_result *spir_sve_result_truncate(const struct spir_sve_result *sve,
                                                 double epsilon,
                                                 int max_size,
                                                 StatusCode *status);

/**
 * Creates a new tau sampling object for sparse sampling in imaginary time
 *
 * # Arguments
 * * `b` - Pointer to a finite temperature basis object
 * * `num_points` - Number of sampling points
 * * `points` - Array of sampling points in imaginary time (τ)
 * * `status` - Pointer to store the status code
 *
 * # Returns
 * Pointer to the newly created sampling object, or NULL if creation fails
 *
 * # Safety
 * Caller must ensure `b` is valid and `points` has `num_points` elements
 */
struct spir_sampling *spir_tau_sampling_new(const struct spir_basis *b,
                                            int num_points,
                                            const double *points,
                                            StatusCode *status);

/**
 * Creates a new tau sampling object with custom sampling points and pre-computed matrix
 *
 * # Arguments
 * * `order` - Memory layout order (SPIR_ORDER_ROW_MAJOR or SPIR_ORDER_COLUMN_MAJOR)
 * * `statistics` - Statistics type (SPIR_STATISTICS_FERMIONIC or SPIR_STATISTICS_BOSONIC)
 * * `basis_size` - Basis size
 * * `num_points` - Number of sampling points
 * * `points` - Array of sampling points in imaginary time (τ)
 * * `matrix` - Pre-computed matrix for the sampling points (num_points x basis_size)
 * * `status` - Pointer to store the status code
 *
 * # Returns
 * Pointer to the newly created sampling object, or NULL if creation fails
 *
 * # Safety
 * Caller must ensure `points` and `matrix` have correct sizes
 */
struct spir_sampling *spir_tau_sampling_new_with_matrix(int order,
                                                        int statistics,
                                                        int basis_size,
                                                        int num_points,
                                                        const double *points,
                                                        const double *matrix,
                                                        StatusCode *status);

#ifdef __cplusplus
}  // extern "C"
#endif  // __cplusplus

#endif  /* SPARSEIR_CAPI_H */
