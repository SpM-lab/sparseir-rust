/**
 * @file sparseir_capi.h
 * @brief C API for SparseIR library (Auto-generated by cbindgen)
 *
 * This header is automatically generated from Rust source code.
 * Do not modify this file manually - edit the Rust sources instead.
 */


#ifndef SPARSEIR_CAPI_H
#define SPARSEIR_CAPI_H

/* Generated with cbindgen:0.27.0 */

/* Warning: This file is autogenerated by cbindgen. Don't modify manually. */

#include <stdarg.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdlib.h>

typedef struct Arc_SVEResult Arc_SVEResult;

/**
 * Internal basis type (not exposed to C)
 */
typedef struct BasisType BasisType;

/**
 * Internal enum to hold different function types
 */
typedef struct FuncsType FuncsType;

/**
 * Internal kernel type (not exposed to C)
 */
typedef struct KernelType KernelType;

/**
 * Error codes for C API (compatible with libsparseir)
 */
typedef int StatusCode;

/**
 * Opaque basis type for C API (compatible with libsparseir)
 *
 * Represents a finite temperature basis (IR or DLR).
 *
 * Note: Named `spir_basis` to match libsparseir C++ API exactly.
 */
typedef struct spir_basis {
    struct BasisType inner;
} spir_basis;

/**
 * Opaque funcs type for C API (compatible with libsparseir)
 *
 * Wraps piecewise Legendre polynomial representations:
 * - PiecewiseLegendrePolyVector for u and v
 * - PiecewiseLegendreFTVector for uhat
 *
 * Note: Named `spir_funcs` to match libsparseir C++ API exactly.
 */
typedef struct spir_funcs {
    struct FuncsType inner;
    double beta;
} spir_funcs;

/**
 * Opaque kernel type for C API (compatible with libsparseir)
 *
 * This is a tagged union that can hold either LogisticKernel or RegularizedBoseKernel.
 * The actual type is determined by which constructor was used.
 *
 * Note: Named `spir_kernel` to match libsparseir C++ API exactly.
 */
typedef struct spir_kernel {
    struct KernelType inner;
} spir_kernel;

/**
 * Opaque SVE result type for C API (compatible with libsparseir)
 *
 * Contains singular values and singular functions from SVE computation.
 *
 * Note: Named `spir_sve_result` to match libsparseir C++ API exactly.
 */
typedef struct spir_sve_result {
    struct Arc_SVEResult inner;
} spir_sve_result;

#define SPIR_COMPUTATION_SUCCESS 0

#define SPIR_GET_IMPL_FAILED -1

#define SPIR_INVALID_DIMENSION -2

#define SPIR_INPUT_DIMENSION_MISMATCH -3

#define SPIR_OUTPUT_DIMENSION_MISMATCH -4

#define SPIR_NOT_SUPPORTED -5

#define SPIR_INVALID_ARGUMENT -6

#define SPIR_INTERNAL_ERROR -7

#define SPIR_SUCCESS SPIR_COMPUTATION_SUCCESS

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

/**
 * Get default Matsubara sampling points
 *
 * # Arguments
 * * `b` - Basis object
 * * `positive_only` - If true, return only positive frequencies
 * * `points` - Pre-allocated array to store Matsubara indices
 *
 * # Returns
 * * `SPIR_SUCCESS` (0) on success
 * * `SPIR_INVALID_ARGUMENT` (-6) if b or points is null
 * * `SPIR_INTERNAL_ERROR` (-7) if internal panic occurs
 */
StatusCode spir_basis_get_default_matsus(const struct spir_basis *b,
                                         bool positive_only,
                                         int64_t *points);

/**
 * Get default tau sampling points
 *
 * # Arguments
 * * `b` - Basis object
 * * `points` - Pre-allocated array to store tau points
 *
 * # Returns
 * * `SPIR_SUCCESS` (0) on success
 * * `SPIR_INVALID_ARGUMENT` (-6) if b or points is null
 * * `SPIR_INTERNAL_ERROR` (-7) if internal panic occurs
 */
StatusCode spir_basis_get_default_taus(const struct spir_basis *b, double *points);

/**
 * Gets the default omega (real frequency) sampling points
 *
 * # Arguments
 * * `b` - Pointer to the finite temperature basis object
 * * `points` - Pre-allocated array to store the omega sampling points
 *
 * # Returns
 * Status code (SPIR_SUCCESS on success)
 *
 * # Safety
 * The caller must ensure that `points` has size >= `spir_basis_get_n_default_ws(b)`
 */
StatusCode spir_basis_get_default_ws(const struct spir_basis *b, double *points);

/**
 * Get the number of default Matsubara sampling points
 *
 * # Arguments
 * * `b` - Basis object
 * * `positive_only` - If true, return only positive frequencies
 * * `num_points` - Pointer to store the number of points
 *
 * # Returns
 * * `SPIR_SUCCESS` (0) on success
 * * `SPIR_INVALID_ARGUMENT` (-6) if b or num_points is null
 * * `SPIR_INTERNAL_ERROR` (-7) if internal panic occurs
 */
StatusCode spir_basis_get_n_default_matsus(const struct spir_basis *b,
                                           bool positive_only,
                                           int *num_points);

/**
 * Get the number of default tau sampling points
 *
 * # Arguments
 * * `b` - Basis object
 * * `num_points` - Pointer to store the number of points
 *
 * # Returns
 * * `SPIR_SUCCESS` (0) on success
 * * `SPIR_INVALID_ARGUMENT` (-6) if b or num_points is null
 * * `SPIR_INTERNAL_ERROR` (-7) if internal panic occurs
 */
StatusCode spir_basis_get_n_default_taus(const struct spir_basis *b, int *num_points);

/**
 * Gets the number of default omega (real frequency) sampling points
 *
 * # Arguments
 * * `b` - Pointer to the finite temperature basis object
 * * `num_points` - Pointer to store the number of sampling points
 *
 * # Returns
 * Status code (SPIR_SUCCESS on success)
 *
 * # Safety
 * The caller must ensure that `b` and `num_points` are valid pointers
 */
StatusCode spir_basis_get_n_default_ws(const struct spir_basis *b, int *num_points);

/**
 * Get singular values (alias for spir_basis_get_svals for libsparseir compatibility)
 */
StatusCode spir_basis_get_singular_values(const struct spir_basis *b, double *svals);

/**
 * Get the number of basis functions
 *
 * # Arguments
 * * `b` - Basis object
 * * `size` - Pointer to store the size
 *
 * # Returns
 * * `SPIR_SUCCESS` (0) on success
 * * `SPIR_INVALID_ARGUMENT` (-6) if b or size is null
 * * `SPIR_INTERNAL_ERROR` (-7) if internal panic occurs
 */
StatusCode spir_basis_get_size(const struct spir_basis *b, int *size);

/**
 * Get statistics type (Fermionic or Bosonic) of a basis
 *
 * # Arguments
 * * `b` - Basis object
 * * `statistics` - Pointer to store statistics (0 = Bosonic, 1 = Fermionic)
 *
 * # Returns
 * * `SPIR_SUCCESS` (0) on success
 * * `SPIR_INVALID_ARGUMENT` (-6) if b or statistics is null
 * * `SPIR_INTERNAL_ERROR` (-7) if internal panic occurs
 */
StatusCode spir_basis_get_stats(const struct spir_basis *b, int *statistics);

/**
 * Get singular values from a basis
 *
 * # Arguments
 * * `b` - Basis object
 * * `svals` - Pre-allocated array to store singular values (size must be >= basis size)
 *
 * # Returns
 * * `SPIR_SUCCESS` (0) on success
 * * `SPIR_INVALID_ARGUMENT` (-6) if b or svals is null
 * * `SPIR_INTERNAL_ERROR` (-7) if internal panic occurs
 */
StatusCode spir_basis_get_svals(const struct spir_basis *b, double *svals);

/**
 * Gets the basis functions in imaginary time (τ) domain
 *
 * # Arguments
 * * `b` - Pointer to the finite temperature basis object
 * * `status` - Pointer to store the status code
 *
 * # Returns
 * Pointer to the basis functions object (`spir_funcs`), or NULL if creation fails
 *
 * # Safety
 * The caller must ensure that `b` is a valid pointer, and must call
 * `spir_funcs_release()` on the returned pointer when done.
 */
struct spir_funcs *spir_basis_get_u(const struct spir_basis *b, StatusCode *status);

/**
 * Gets the basis functions in Matsubara frequency domain
 *
 * # Arguments
 * * `b` - Pointer to the finite temperature basis object
 * * `status` - Pointer to store the status code
 *
 * # Returns
 * Pointer to the basis functions object (`spir_funcs`), or NULL if creation fails
 *
 * # Safety
 * The caller must ensure that `b` is a valid pointer, and must call
 * `spir_funcs_release()` on the returned pointer when done.
 */
struct spir_funcs *spir_basis_get_uhat(const struct spir_basis *b, StatusCode *status);

/**
 * Gets the basis functions in real frequency (ω) domain
 *
 * # Arguments
 * * `b` - Pointer to the finite temperature basis object
 * * `status` - Pointer to store the status code
 *
 * # Returns
 * Pointer to the basis functions object (`spir_funcs`), or NULL if creation fails
 *
 * # Safety
 * The caller must ensure that `b` is a valid pointer, and must call
 * `spir_funcs_release()` on the returned pointer when done.
 */
struct spir_funcs *spir_basis_get_v(const struct spir_basis *b, StatusCode *status);

/**
 * Create a finite temperature basis (libsparseir compatible)
 *
 * # Arguments
 * * `statistics` - 0 for Bosonic, 1 for Fermionic
 * * `beta` - Inverse temperature (must be > 0)
 * * `omega_max` - Frequency cutoff (must be > 0)
 * * `epsilon` - Accuracy target (must be > 0)
 * * `k` - Kernel object (can be NULL if sve is provided)
 * * `sve` - Pre-computed SVE result (can be NULL, will compute if needed)
 * * `max_size` - Maximum basis size (-1 for no limit)
 * * `status` - Pointer to store status code
 *
 * # Returns
 * * Pointer to basis object, or NULL on failure
 *
 * # Safety
 * The caller must ensure `status` is a valid pointer.
 */
struct spir_basis *spir_basis_new(int statistics,
                                  double beta,
                                  double omega_max,
                                  double epsilon,
                                  const struct spir_kernel *k,
                                  const struct spir_sve_result *sve,
                                  int max_size,
                                  StatusCode *status);

/**
 * Release a basis object
 *
 * # Arguments
 * * `b` - Basis to release (can be NULL)
 *
 * # Safety
 * After calling this function, the basis pointer is invalid and must not be used.
 */
void spir_basis_release(struct spir_basis *b);

/**
 * Releases a funcs object
 *
 * # Arguments
 * * `funcs` - Pointer to the funcs object to release
 *
 * # Safety
 * The caller must ensure that `funcs` is a valid pointer returned from a previous
 * `spir_basis_get_u/v/uhat()` call, and that it is not used after this function returns.
 */
void spir_funcs_release(struct spir_funcs *funcs);

/**
 * Compute kernel value K(x, y)
 *
 * # Arguments
 * * `kernel` - Kernel object
 * * `x` - First argument (typically in [-1, 1])
 * * `y` - Second argument (typically in [-1, 1])
 * * `out` - Pointer to store the result
 *
 * # Returns
 * * `SPIR_SUCCESS` on success
 * * `SPIR_INVALID_ARGUMENT` if kernel or out is null
 * * `SPIR_INTERNAL_ERROR` if internal panic occurs
 */
StatusCode spir_kernel_compute(const struct spir_kernel *kernel, double x, double y, double *out);

/**
 * Get the lambda parameter of a kernel
 *
 * # Arguments
 * * `kernel` - Kernel object
 * * `lambda_out` - Pointer to store the lambda value
 *
 * # Returns
 * * `SPIR_SUCCESS` on success
 * * `SPIR_INVALID_ARGUMENT` if kernel or lambda_out is null
 * * `SPIR_INTERNAL_ERROR` if internal panic occurs
 */
StatusCode spir_kernel_lambda(const struct spir_kernel *kernel, double *lambda_out);

/**
 * Release a kernel object
 *
 * # Arguments
 * * `kernel` - Kernel to release (can be NULL)
 *
 * # Safety
 * After calling this function, the kernel pointer is invalid and must not be used.
 */
void spir_kernel_release(struct spir_kernel *kernel);

/**
 * Create a new Logistic kernel
 *
 * # Arguments
 * * `lambda` - The kernel parameter Λ = β * ωmax (must be > 0)
 * * `status` - Pointer to store the status code
 *
 * # Returns
 * * Pointer to the newly created kernel object, or NULL if creation fails
 *
 * # Safety
 * The caller must ensure `status` is a valid pointer.
 *
 * # Example (C)
 * ```c
 * int status;
 * spir_kernel* kernel = spir_logistic_kernel_new(10.0, &status);
 * if (kernel != NULL) {
 *     // Use kernel...
 *     spir_kernel_release(kernel);
 * }
 * ```
 */
struct spir_kernel *spir_logistic_kernel_new(double lambda, StatusCode *status);

/**
 * Create a new RegularizedBose kernel
 *
 * # Arguments
 * * `lambda` - The kernel parameter Λ = β * ωmax (must be > 0)
 * * `status` - Pointer to store the status code
 *
 * # Returns
 * * Pointer to the newly created kernel object, or NULL if creation fails
 */
struct spir_kernel *spir_reg_bose_kernel_new(double lambda, StatusCode *status);

/**
 * Get the number of singular values in an SVE result
 *
 * # Arguments
 * * `sve` - SVE result object
 * * `size` - Pointer to store the size
 *
 * # Returns
 * * `SPIR_SUCCESS` (0) on success
 * * `SPIR_INVALID_ARGUMENT` (-6) if sve or size is null
 * * `SPIR_INTERNAL_ERROR` (-7) if internal panic occurs
 */
StatusCode spir_sve_result_get_size(const struct spir_sve_result *sve, int *size);

/**
 * Get singular values from an SVE result
 *
 * # Arguments
 * * `sve` - SVE result object
 * * `svals` - Pre-allocated array to store singular values (size must be >= result size)
 *
 * # Returns
 * * `SPIR_SUCCESS` (0) on success
 * * `SPIR_INVALID_ARGUMENT` (-6) if sve or svals is null
 * * `SPIR_INTERNAL_ERROR` (-7) if internal panic occurs
 */
StatusCode spir_sve_result_get_svals(const struct spir_sve_result *sve, double *svals);

/**
 * Compute Singular Value Expansion (SVE) of a kernel (libsparseir compatible)
 *
 * # Arguments
 * * `k` - Kernel object
 * * `epsilon` - Accuracy target for the basis
 * * `cutoff` - Cutoff value for singular values (-1 for default: 2*sqrt(machine_epsilon))
 * * `lmax` - Maximum number of Legendre polynomials (currently ignored, auto-determined)
 * * `n_gauss` - Number of Gauss points for integration (currently ignored, auto-determined)
 * * `Twork` - Working precision: 0=Float64, 1=Float64x2, -1=Auto
 * * `status` - Pointer to store status code
 *
 * # Returns
 * * Pointer to SVE result, or NULL on failure
 *
 * # Safety
 * The caller must ensure `status` is a valid pointer.
 *
 * # Note
 * Parameters `lmax` and `n_gauss` are accepted for libsparseir compatibility but
 * currently ignored. The Rust implementation automatically determines optimal values.
 */
struct spir_sve_result *spir_sve_result_new(const struct spir_kernel *k,
                                            double epsilon,
                                            double cutoff,
                                            int _lmax,
                                            int _n_gauss,
                                            int twork,
                                            StatusCode *status);

/**
 * Release an SVE result object
 *
 * # Arguments
 * * `sve` - SVE result to release (can be NULL)
 *
 * # Safety
 * After calling this function, the sve pointer is invalid and must not be used.
 */
void spir_sve_result_release(struct spir_sve_result *sve);

/**
 * Truncate an SVE result
 *
 * # Arguments
 * * `sve` - SVE result object
 * * `epsilon` - New accuracy target
 * * `max_size` - Maximum number of singular values to keep (-1 for no limit)
 * * `status` - Pointer to store status code
 *
 * # Returns
 * * Pointer to new truncated SVE result, or NULL on failure
 *
 * # Safety
 * The caller must ensure `status` is a valid pointer.
 */
struct spir_sve_result *spir_sve_result_truncate(const struct spir_sve_result *sve,
                                                 double epsilon,
                                                 int max_size,
                                                 StatusCode *status);

#ifdef __cplusplus
}  // extern "C"
#endif  // __cplusplus

#endif  /* SPARSEIR_CAPI_H */
