/**
 * @file sparseir_capi.h
 * @brief C API for SparseIR library (Auto-generated by cbindgen)
 *
 * This header is automatically generated from Rust source code.
 * Do not modify this file manually - edit the Rust sources instead.
 */


#ifndef SPARSEIR_CAPI_H
#define SPARSEIR_CAPI_H

/* Generated with cbindgen:0.27.0 */

/* Warning: This file is autogenerated by cbindgen. Don't modify manually. */

#include <stdarg.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdlib.h>

/**
 * Internal kernel type (not exposed to C)
 */
typedef struct KernelType KernelType;

/**
 * Error codes for C API
 */
typedef int SparseIRStatus;

/**
 * Opaque kernel type for C API
 *
 * This is a tagged union that can hold either LogisticKernel or RegularizedBoseKernel.
 * The actual type is determined by which constructor was used.
 */
typedef struct SparseIRKernel {
    struct KernelType inner;
} SparseIRKernel;

#define SPIR_SUCCESS 0

#define SPIR_ERROR_NULL_POINTER -1

#define SPIR_ERROR_INVALID_ARGUMENT -2

#define SPIR_ERROR_PANIC -99

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

/**
 * Compute kernel value K(x, y)
 *
 * # Arguments
 * * `kernel` - Kernel object
 * * `x` - First argument (typically in [-1, 1])
 * * `y` - Second argument (typically in [-1, 1])
 * * `out` - Pointer to store the result
 *
 * # Returns
 * * `SPIR_SUCCESS` on success
 * * `SPIR_ERROR_NULL_POINTER` if kernel or out is null
 * * `SPIR_ERROR_PANIC` if internal panic occurs
 */
SparseIRStatus spir_kernel_compute(const struct SparseIRKernel *kernel,
                                   double x,
                                   double y,
                                   double *out);

/**
 * Get the lambda parameter of a kernel
 *
 * # Arguments
 * * `kernel` - Kernel object
 * * `out` - Pointer to store the lambda value
 *
 * # Returns
 * * `SPIR_SUCCESS` on success
 * * `SPIR_ERROR_NULL_POINTER` if kernel or out is null
 * * `SPIR_ERROR_PANIC` if internal panic occurs
 */
SparseIRStatus spir_kernel_lambda(const struct SparseIRKernel *kernel, double *out);

/**
 * Create a new Logistic kernel
 *
 * # Arguments
 * * `lambda` - The kernel parameter Λ = β * ωmax (must be > 0)
 * * `out` - Pointer to store the created kernel
 *
 * # Returns
 * * `SPIR_SUCCESS` on success
 * * `SPIR_ERROR_NULL_POINTER` if out is null
 * * `SPIR_ERROR_INVALID_ARGUMENT` if lambda <= 0
 * * `SPIR_ERROR_PANIC` if internal panic occurs
 *
 * # Safety
 * The caller must ensure `out` is a valid pointer.
 *
 * # Example (C)
 * ```c
 * SparseIRKernel* kernel = NULL;
 * int status = spir_kernel_logistic_new(10.0, &kernel);
 * if (status == SPIR_SUCCESS) {
 *     // Use kernel...
 *     spir_kernel_release(kernel);
 * }
 * ```
 */
SparseIRStatus spir_kernel_logistic_new(double lambda, struct SparseIRKernel **out);

/**
 * Create a new RegularizedBose kernel
 *
 * # Arguments
 * * `lambda` - The kernel parameter Λ = β * ωmax (must be > 0)
 * * `out` - Pointer to store the created kernel
 *
 * # Returns
 * * `SPIR_SUCCESS` on success
 * * `SPIR_ERROR_NULL_POINTER` if out is null
 * * `SPIR_ERROR_INVALID_ARGUMENT` if lambda <= 0
 * * `SPIR_ERROR_PANIC` if internal panic occurs
 */
SparseIRStatus spir_kernel_regularized_bose_new(double lambda, struct SparseIRKernel **out);

/**
 * Release a kernel object
 *
 * # Arguments
 * * `kernel` - Kernel to release (can be NULL)
 *
 * # Safety
 * After calling this function, the kernel pointer is invalid and must not be used.
 */
void spir_kernel_release(struct SparseIRKernel *kernel);

#ifdef __cplusplus
}  // extern "C"
#endif  // __cplusplus

#endif  /* SPARSEIR_CAPI_H */
