/**
 * @file sparseir_capi.h
 * @brief C API for SparseIR library (Auto-generated by cbindgen)
 *
 * This header is automatically generated from Rust source code.
 * Do not modify this file manually - edit the Rust sources instead.
 */


#ifndef SPARSEIR_CAPI_H
#define SPARSEIR_CAPI_H

/* Generated with cbindgen:0.27.0 */

/* Warning: This file is autogenerated by cbindgen. Don't modify manually. */

#include <stdarg.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdlib.h>

/**
 * Internal kernel type (not exposed to C)
 */
typedef struct KernelType KernelType;

/**
 * Error codes for C API (compatible with libsparseir)
 */
typedef int SparseIRStatus;

/**
 * Opaque kernel type for C API
 *
 * This is a tagged union that can hold either LogisticKernel or RegularizedBoseKernel.
 * The actual type is determined by which constructor was used.
 */
typedef struct SparseIRKernel {
    struct KernelType inner;
} SparseIRKernel;

#define SPIR_COMPUTATION_SUCCESS 0

#define SPIR_GET_IMPL_FAILED -1

#define SPIR_INVALID_DIMENSION -2

#define SPIR_INPUT_DIMENSION_MISMATCH -3

#define SPIR_OUTPUT_DIMENSION_MISMATCH -4

#define SPIR_NOT_SUPPORTED -5

#define SPIR_INVALID_ARGUMENT -6

#define SPIR_INTERNAL_ERROR -7

#define SPIR_SUCCESS SPIR_COMPUTATION_SUCCESS

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

/**
 * Compute kernel value K(x, y)
 *
 * # Arguments
 * * `kernel` - Kernel object
 * * `x` - First argument (typically in [-1, 1])
 * * `y` - Second argument (typically in [-1, 1])
 * * `out` - Pointer to store the result
 *
 * # Returns
 * * `SPIR_SUCCESS` on success
 * * `SPIR_INVALID_ARGUMENT` if kernel or out is null
 * * `SPIR_INTERNAL_ERROR` if internal panic occurs
 */
SparseIRStatus spir_kernel_compute(const struct SparseIRKernel *kernel,
                                   double x,
                                   double y,
                                   double *out);

/**
 * Get the lambda parameter of a kernel
 *
 * # Arguments
 * * `kernel` - Kernel object
 * * `lambda_out` - Pointer to store the lambda value
 *
 * # Returns
 * * `SPIR_SUCCESS` on success
 * * `SPIR_INVALID_ARGUMENT` if kernel or lambda_out is null
 * * `SPIR_INTERNAL_ERROR` if internal panic occurs
 */
SparseIRStatus spir_kernel_lambda(const struct SparseIRKernel *kernel, double *lambda_out);

/**
 * Create a new Logistic kernel
 *
 * # Arguments
 * * `lambda` - The kernel parameter Λ = β * ωmax (must be > 0)
 * * `status` - Pointer to store the status code
 *
 * # Returns
 * * Pointer to the newly created kernel object, or NULL if creation fails
 *
 * # Safety
 * The caller must ensure `status` is a valid pointer.
 *
 * # Example (C)
 * ```c
 * int status;
 * SparseIRKernel* kernel = spir_kernel_logistic_new(10.0, &status);
 * if (kernel != NULL) {
 *     // Use kernel...
 *     spir_kernel_release(kernel);
 * }
 * ```
 */
struct SparseIRKernel *spir_kernel_logistic_new(double lambda, SparseIRStatus *status);

/**
 * Create a new RegularizedBose kernel
 *
 * # Arguments
 * * `lambda` - The kernel parameter Λ = β * ωmax (must be > 0)
 * * `status` - Pointer to store the status code
 *
 * # Returns
 * * Pointer to the newly created kernel object, or NULL if creation fails
 */
struct SparseIRKernel *spir_kernel_regularized_bose_new(double lambda, SparseIRStatus *status);

/**
 * Release a kernel object
 *
 * # Arguments
 * * `kernel` - Kernel to release (can be NULL)
 *
 * # Safety
 * After calling this function, the kernel pointer is invalid and must not be used.
 */
void spir_kernel_release(struct SparseIRKernel *kernel);

#ifdef __cplusplus
}  // extern "C"
#endif  // __cplusplus

#endif  /* SPARSEIR_CAPI_H */
