# spir_funcs Design Document

## Overview

`spir_funcs` is an opaque C type that wraps Rust's piecewise polynomial representations:
- `PiecewiseLegendrePolyVector` (for u and v)
- `PiecewiseLegendreFTVector<S>` (for uhat)

## libsparseir C++ Implementation

```cpp
// Opaque type definition
IMPLEMENT_OPAQUE_TYPE(funcs, _AbstractFuncs)

// Creates:
struct _spir_funcs {
    std::shared_ptr<_AbstractFuncs> ptr;
};

static inline spir_funcs *create_funcs(std::shared_ptr<_AbstractFuncs> p);
```

### Abstract Interface Hierarchy

```cpp
class _AbstractFuncs {
    virtual int size() const = 0;
    virtual bool is_continuous_funcs() const = 0;
    virtual shared_ptr<_AbstractFuncs> slice(const vector<size_t>&) const = 0;
};

class AbstractContinuousFunctions : public _AbstractFuncs {
    virtual VectorXd operator()(double x) const = 0;
    virtual MatrixXd operator()(const VectorXd &xs) const = 0;
    virtual pair<double, double> get_domain() const = 0;
    virtual int nroots() const = 0;
    virtual VectorXd roots() const = 0;
    virtual VectorXd get_knots() const = 0;
};

class AbstractMatsubaraFunctions : public _AbstractFuncs {
    virtual MatrixXcd operator()(const Array<int64_t, Dynamic, 1>&) const = 0;
};
```

## Rust Design

### Type Definition

```rust
use sparseir_rust::poly::PiecewiseLegendrePolyVector;
use sparseir_rust::polyfourier::PiecewiseLegendreFTVector;
use sparseir_rust::freq::{Fermionic, Bosonic};

enum FuncsType {
    /// u, v: imaginary-time and real-frequency basis functions
    PolyVector(Arc<PiecewiseLegendrePolyVector>),
    
    /// uhat: Matsubara-frequency basis functions (Fermionic)
    FTVectorFermionic(Arc<PiecewiseLegendreFTVector<Fermionic>>),
    
    /// uhat: Matsubara-frequency basis functions (Bosonic)
    FTVectorBosonic(Arc<PiecewiseLegendreFTVector<Bosonic>>),
}

#[repr(C)]
pub struct spir_funcs {
    inner: FuncsType,
    beta: f64,  // Needed for tau -> x conversion
}
```

### Creation Patterns

From `spir_basis_get_u()`:
```rust
// For IR basis, u is PiecewiseLegendrePolyVector
let funcs = spir_funcs {
    inner: FuncsType::PolyVector(basis.u.clone()),  // u is Arc already
    beta: basis.beta(),
};
Box::into_raw(Box::new(funcs))
```

From `spir_basis_get_v()`:
```rust
// For IR basis, v is PiecewiseLegendrePolyVector
let funcs = spir_funcs {
    inner: FuncsType::PolyVector(basis.v.clone()),  // v is Arc already
    beta: basis.beta(),
};
Box::into_raw(Box::new(funcs))
```

From `spir_basis_get_uhat()`:
```rust
// For IR basis, uhat is PiecewiseLegendreFTVector<S>
let funcs = match &basis.inner {
    BasisType::LogisticFermionic(b) => spir_funcs {
        inner: FuncsType::FTVectorFermionic(b.uhat.clone()),
        beta: b.beta(),
    },
    BasisType::LogisticBosonic(b) => spir_funcs {
        inner: FuncsType::FTVectorBosonic(b.uhat.clone()),
        beta: b.beta(),
    },
    // ... similar for RegularizedBose variants
};
Box::into_raw(Box::new(funcs))
```

## Required Functions (Phase 1)

### Basic Management
1. `spir_funcs_release()` - Free the object ✅ (auto-generated by macro in C++)
2. `spir_funcs_clone()` - Clone the object ✅ (auto-generated)
3. `spir_funcs_get_size()` - Get number of basis functions

### Evaluation
4. `spir_funcs_eval()` - Evaluate at single tau point
5. `spir_funcs_eval_matsu()` - Evaluate at single Matsubara frequency
6. `spir_funcs_batch_eval()` - Evaluate at multiple tau points
7. `spir_funcs_batch_eval_matsu()` - Evaluate at multiple Matsubara frequencies

### Introspection
8. `spir_funcs_get_n_knots()` - Get number of knots
9. `spir_funcs_get_knots()` - Get knot positions
10. `spir_funcs_get_slice()` - Create subset of basis functions

## Coordinate Transformations

### Tau Domain
- **Input (C-API)**: tau ∈ [-beta, beta]
- **Internal (Rust)**: x ∈ [-1, 1]
- **Conversion**: x = 2*tau/beta - 1  (for tau ∈ [0, beta])
  - For tau < 0: use symmetry

### Matsubara Frequencies
- **Fermionic**: iωn = (2n+1)π/β
- **Bosonic**: iωn = 2nπ/β
- Input: index `n`
- Create `MatsubaraFreq::new(n, beta)` and evaluate

## Implementation Strategy

### Phase 1: Minimum Viable (for Basis API)
Just implement creation:
- `spir_basis_get_u()` → returns `spir_funcs` wrapping `u`
- `spir_basis_get_v()` → returns `spir_funcs` wrapping `v`
- `spir_basis_get_uhat()` → returns `spir_funcs` wrapping `uhat`
- `spir_funcs_release()` → basic cleanup

### Phase 2: Evaluation Functions
- `spir_funcs_eval()`
- `spir_funcs_batch_eval()`
- `spir_funcs_eval_matsu()`
- `spir_funcs_batch_eval_matsu()`

### Phase 3: Advanced Features
- `spir_funcs_get_size()`
- `spir_funcs_get_knots()`
- `spir_funcs_get_slice()`

## Memory Management

- Use `Arc<T>` for shared ownership (already in `FiniteTempBasis`)
- `spir_funcs` owns the `Arc`, so `clone()` is cheap (ref count increment)
- `release()` decrements ref count

## Error Handling

Same pattern as other C-API functions:
```rust
let result = catch_unwind(|| {
    // ... operation
});
match result {
    Ok(Ok(ptr)) => {
        unsafe { *status = SPIR_SUCCESS; }
        ptr
    },
    Ok(Err(msg)) => {
        eprintln!("Error: {}", msg);
        unsafe { *status = SPIR_INTERNAL_ERROR; }
        std::ptr::null_mut()
    },
    Err(_) => {
        unsafe { *status = SPIR_INTERNAL_ERROR; }
        std::ptr::null_mut()
    }
}
```

## Notes

- `beta` is stored in `spir_funcs` because it's needed to convert between tau and x coordinates
- `uhat` requires statistics type (Fermionic/Bosonic) which is encoded in the `FuncsType` enum
- The C-API user doesn't need to know the internal type - they just call eval functions

